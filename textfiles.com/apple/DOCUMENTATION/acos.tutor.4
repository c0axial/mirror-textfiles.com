   OPEN
syntax:  OPEN #device,filename

the OPEN statement is used to make disk files ready to do i/o with out a program. you open a disk file using either device channel 1 or 2, and all further references to that channel will access the file associated with it. when you are finished with the file, use the CLOSE command. this will free up the device channel for later use. if you try to use a channel that is already in use, or one besides channel 1 or 2, you will get a BAD DEVICE CHANNEL error. if the file you open does not exist, no error will be generated. if you try to read from the file, it will appear to be empty. use the CREATE command to make a file.
-------------------------

         PDL
syntax:  expression=PDL(number)

the PDL function is used to read one of the paddles on the system. you can read paddle zero through three. the number returned will be in the range 0-255.
-------------------------

         PEEK
syntax:  expression=PEEK(address)

appears to be the same as the applesoft PEEK function.
-------------------------

         POKE
syntax:  POKE address,value

appears to be the same as the applesoft PEEK function.
-------------------------

         POP
syntax:  POP

appears to be the same as the applesoft POP statement with the exception of it also can be used with the acos PUSH command.
-------------------------

         POSITION
syntax:  POSITION #device,number,number [,number]

the POSITION statement is used to position within a random access file. the first argument is the disk device channel number that was used to open the file. the second field is the length of each record. the third field is the record number to be positioned to. the fourth field is the offset with in the record that is to be positioned to.
-------------------------

         PRINT
syntax:  PRINT [#device,] [expression]
               [,expression] [;]

rules for PRINT:

         control: ',' - the comma is used to separate expressions within the
                        print statement and will be printed literally.

         control: ';' - the semi-colon is also used to separate expressions
                        it will not be printed when encountered, if a semi-
                        colon is the last character in the line, then the
                        carriage return will be suppressed.

         control: '\' - the backslash is used to generate a newline character
                         using the backslash, there is no need to put a bunch
                         of print:print... statements.

         exprs: TEXT  - text must be contained within quotes and will be
                        printed exactly as typed. within quotes, you may have
                        any special characters including return. having an
                        open quote with no close can prove to be an
                        interesting experience.

         exprs: STRING- the contents of the listed string will be printed.

         exprs: NUMBER- the content of the listed number will be printed.
-------------------------

         PUBLIC
syntax:  PUBLIC label

the PUBLIC statement is used to make a label within a program module available to other modules to link to. if you wish to link to another program module, and start execution at a point other than the beginning of the module, you will need to make that point public. you can have a maximum of 8 public labels within a program module.
-------------------------

         PUSH
syntax:  PUSH label

the PUSH statement is a sub-set of the GOSUB statement. it does not actually change the current point of execution, but places a return address in a table so that the next time a RETURN statement is encountered, control will return to this present point. a POP statement will remove the last address added to the return table.
-------------------------

         RAM
syntax:  RAM

the RAM function is really just a constant pointer. it just points to a free 64 bytes of memory that has been set aside for program use.
-------------------------

         RAM2
syntax:  RAM2

the RAM2 function is the same as the RAM function except that it points to a different 64 bytes that are available for program use. generally this memory is used in conjunction with the READ, WRITE, NIBBLE and BYTE functions.
-------------------------

         RANDOM
syntax:  expression=RANDOM(number)

the RANDOM function is used to generate a random number within the range 0-number. a new random number will be generated everytime the system goes to get input. if you take two random numbers in a row, they will always be the same. if you need more than one, use the RND$ string between. the will do a temporary re-random.
-------------------------

         READ
syntax:  READ # device,memloc,number

the READ statement is used to load data from a file into memory in its binary form without any processing or changing. the input does not have to come from a file, it can come from the editor or a message file. it is similar to an apple dos BLOAD command.
-------------------------

         READY
syntax:  READY filename
         READY #MSG(number)

the READY statement is used to make a message file ready for use. it is similar to an OPEN statement being used before a file is accessed. after a message file is ready, all the following references to MSG will be directed to that file. once a message file has been made ready, it can also be used in its second syntax to ready a specific message within the file.this is generally used if further references to the file will use the device channel associated with the message base.
-------------------------

         RETURN
syntax:  RETURN

appears to have same function as the applesoft RETURN statement.
-------------------------

         REWIND
syntax:  REWIND

the REWIND statement is to change the pointer within a message file to some previously accessed point within the file. normally this is used in conjunction with the READY MSG(x):COPY #7 statements. using REWIND will put the internal pointer back to where it was before the last message operation took place. this is generally used for doing a 're-read' function of sorts.
-------------------------

         RIGHT$
syntax:  string=RIGHT$(string,length)

appears to have same function as the applesoft RIGHT$.
-------------------------

         RND$
syntax:  char=RND$

the RND$ function is used to generate  random characters. each time RND$ is accessed a new random character will be returned. be warned: the random number is generated from timing how long a user takes to enter his input. this is really a pretty random number since it is based on the users typing skill and speed. the only problem is that the random character generator can start repeating patterns after about 15-20 characters have been generated and before another input has taken place.
-------------------------

         SET
syntax:  SET string=memloc,number

the SET statement is another statement set up for the optimum management of memory. with SET you can manually set up pointers for strings anywhere in memory. along with the locations of the string, you can also specify the length. whenever the string is accessed, the text present at the memory locations will be returned.
-------------------------

         SETINT
syntax:  SETINT (string1 [,string1...])
         SETINT ("")
         SETINT (number)

the SETINT command is used to set up 'interrupt' keys. once setup the system will check for those keys whenever text is being displayed. if one of the keys are encountered, all further output will be supressed until an input statement of some kind is encountered or the SETINT is reset. to reset the SETINT command, use the second syntax. if you wish to set the interrupt keys to those pre-defined by the acos config program, use the third syntax. SETINT(1) will set the interrupt key to the 'file stop' character. SETINT(2) will set the interrupt keys to the 'file stop' and 'file next' characters.
-------------------------

         STR$
syntax:  string=STR$(number)

appears to have same function as the applesoft STR$.
-------------------------

         TEXT
syntax:  TEXT

used to clear the screen and any window on the local console.
-------------------------

         THEN
syntax:  THEN

same as applesoft THEN, separates statements within IF statements.
-------------------------

         TIME$
syntax:  string=TIME$

the TIME$ function is used to get the current time from your clock. if your system is equipped with a clock, the time will be returned in a "HH:MM:SS XM" format. if your clock is in the 24 hour configuration then it will be returned in the "HH:MM:SS" format. if you have no clock, then your estimated time on will be returned. the estimated time is based upon the number of characters output and the speed they were sent. the format for estimated time is "HH:MM:SS ET". when the clock is first reset via a MODEM(0) command, the time will be "00:00:00 ET" and will advance from there.
-------------------------

         TONE
syntax:  TONE (number,number)

the TONE function is used to generate a tone from the speaker in your computer. the first argument is the pitch and the second is the duration.
-------------------------

         UPDATE
syntax:  UPDATE

the UPDATE statement is used to write any information about the current message base from memory out to disk. normally, certain things are buffered and will stay within memory for long periods of time. in the event of a power failure or a system reset, this data will be lost before it is written out to disk. use the UPDATE statement to force the data to be written out to disk.
-------------------------

         USE
syntax:  USE filename [,any options]

the USE statement is used to access a routine that is external to the acos language. what happens is that the USE statement loads in an external command and transfer control to that command. the command will normally get parameters from the continuation of the line after the filename argument.
-------------------------

         VAL
syntax:  expression=VAL(string)

appears to have same function as applesoft VAL.
-------------------------

         WHEN$
syntax:  WHEN$=address
         string=WHEN$
         WHEN$=string

the WHEN$ function is really just a data compression scheme. you initially point WHEN$ to a address in memory. at this address there must be 2 free bytes. when you read from WHEN$, the 2 bytes will be retrieved from the memory location and translated into a "MM/DD/YY" format. when you assign WHEN$ a value, the current date will be read and changed into a 2 byte compressed format and saved at the current address pointer.
-------------------------

         WIDTH
syntax:  expression=WIDTH(number)

the WIDTH function is really an interface to the config program. it will return 4 widths that were setup as the most commonly used widths under config, along with the width that should be used for a default when the video width is not known. WIDTH(1-4) will return the 4 most commonly used widths. WIDTH(0) will return the number of the width(1-4) that should be used as a default.
-------------------------

         WRITE
syntax:  WRITE #device,memloc,number

the WRITE statement is the opposite of the READ statement. it is used to write unprocessed binary data from memory to a file or other device. almost all the device channels can be written and none will generate errors. just specify the memory location and length to be written.
-------------------------

* end of fiLE
 

[Ripco] Which 1-241 ?=menu,<CR>=abort: