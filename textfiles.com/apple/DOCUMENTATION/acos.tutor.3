
[--------------------------------------------------]
[                A C O S     Tutorial 2            ]
[                                                  ]
[--------------------------------------------------]
-------------------------

ACOS COMMANDS & FUNCTIONS

-------------------------
         ADDINT
syntax:  ADDINT (string1 [,string1...])

the ADDINT command will add more keys to the existing interrupt keys table. previous keys will not be cleared. the functions of the keys is the same as with the SETINT command.
-------------------------

         APPEND
syntax:  APPEND #device

the APPEND statement is generally used to add data to an existing file. if you issue an APPEND statement,the file pointer will be moved to the end of the file. you can also find out the length of a file by doing an APPEND and then using the MARK function. Mark will then return the length of the file in bytes.
-------------------------

         BYTE
syntax:  BYTE=number
         BYTE=(number)
         BYTE=(number)=number256

the BYTE function is similar to the FLAG function. it is a low overhead data storage unit. just point to where in memory you want the data to be stored using the first syntax, and you can then access the data using the second or third syntax's.
-------------------------

         CHR$
syntax:  string=CHR$(ascii code [,number chars])

appears to be same as in Applesoft with the exception of [,number chars] which allows user to define how many ascii codes are to be assigned to string.
-------------------------

         CLEAR
syntax:  CLEAR
         CLEAR #device

the forms to clears share only one thing in common; they both clear data in one form or another. in the first syntax, without an argument, CLEAR will reset all the variables to nil, clear all the addresses from the for-next and gosub-return stack, and close all open files. suggested use is at beginning of program.

in its second syntax, CLEAR is used to clear out device buffers. the legal device channels are 8,9,10. CLEAR #8 will clear the editor so that any output into the editor will be appended to a clear editor. CLEAR #9 will clear the top of screen display. You must clear the top of screen display before you write any info into it. CLEAR #10 will clear the ram drive. any further writes will be appended on to the end.
-------------------------

         CLOCK
syntax:  CLOCK(0)
         CLOCK(1)=expression
         expression=CLOCK(2)

the CLOCK function/statement is used for setting a time limit. it can also be used to find out how long someone has been using the system. the following options are available.

         CLOCK(0)- this statement is used to reset the clock time to zero.
                   it should be executed when your program begins.

         CLOCK(1)- you will need to set CLOCK(1) equal to the number of
                   minutes you want as a time limit, or 0 for no limit. when
                   the time limit expires, it will be handled as a "no                            carrier" situation. The program will jump to the NOCAR
                   routine.

         CLOCK(2)- the CLOCK(2) function will return the number of seconds
                   that a user has been connected. divide this number by 60
                   to find how many minutes they have been connected.
-------------------------

         CLOSE
syntax:  CLOSE
         CLOSE #device

the CLOSE command is used to close a disk file after you are done with it. if you give a device channel with the close command, only that file will be closed. if you CLOSE by itself, all open files will be closed.
-------------------------

         COPY
syntax:  COPY filename [,#device]
         COPY #device [,#device]

the COPY command is used for displaying and copying information from device to device. the first argument can be a filemane, in which case, the file is opened and input is taken from that file, or it can be a device. the second device is optional. if present all output will be routed there, otherwise it will be displayed to the modem/console. the second argument may not be another filename. if you wish to copy to a file, open the file with the OPEN command, and copy to that device.
-------------------------

         CREATE
syntax:  CREATE filename

the CREATE statement is used to create an empty file on the disk. the new file can be opened and read and written to just as any other file would be. this is the only way to create a file under acos. unlike some other basics, acos will NOT create a file using the OPEN command.
-------------------------

         CRUNCH
syntax:  CRUNCH

the CRUNCH statement is used in conjunction with the MSG commands. it is used to "CRUNCH" together a message file in while messages have been killed. this allows you to maintain a sequential message file and get rid of all the blank deleted entries that might be there.
-------------------------

         DATE$
syntax:  string=DATE$

the DATE$ function returns the current date in MM/DD/YY format. the input will be taken from whatever device was configured as a clock. if 00/00/00 is returned, then there is no clock in the system and the date hasn't been set.
-------------------------

         ECHO
syntax:  ECHO=string1
         ECHO=""

the ECHO statement is used to set the echo character to be used with the INPUT statement. once the echo has been set, that character will be sent each time a user types a character when entering text. the ECHO statement in the second syntax will reset the echo to the character that is being typed.
-------------------------

         EDIT
syntax:  EDIT(number)

the EDIT statement is the command used to interface acos with its editor. with the different EDIT statements, you can clear the editor, see how much space is free, etc. the following list gives all legal calls....

         EDIT(0)- clears the editor. there will be a total of 4096 bytes free
                  after a clear takes place.

         EDIT(1)- enter the editor. if no data is present, the editor will 
                  start to accept input right away. if other data is 
                  present, the editor will start in the prompt mode.

         EDIT(2)- this is a function that returns the number of bytes used
                  within the editor. if this number equals 0 the editor is
                  empty.

         EDIT(3)- this is used to set the video width to be used within the
                  editor. any value from 1 to 255 is legal. the most often
                  used widths are 32,40,64,80,128. all operations within the
                  editor will be based around this width. you can also read
                  the current width using EDIT(3) as a function.

         EDIT(4)- this is used to set the 'back-space mode' that the editor
                  will use. certain modes allow more control than others.
                  mode 0 indicates that the actual mode is not known. the
                  editor will work fine, but some functions will be
                  disabled. under mode 1, the editor will assume that the
                  user has a 'non-destructible' backspace. this allows all
                  the editor functions to be used and is how the local console
                  is setup. mode 2 tells the editor that the user has a
                  'destructible' backspace. under this mode, some functions
                  are disabled, but the editor speeds up certain other
                  functions.
-------------------------

         END
syntax:  END

same as applesoft, terminates program. returns to acos restart state.
-------------------------

         FILL

syntax:  FILL start,length,data

the FILL statement is used to fill an area of memory with some bytes of data. generally it is used to zero out memory. START is a 16 bit memory address, length is an 8 bit [0-255] number, and DATA is the byte that will be used to fill memory.
-------------------------

         FLAG
syntax:  expression=FLAG
         FLAG=number
         FLAG=(number)
         FLAG(number)=number1

the FLAG function is a low overhead way to store 1 bit information. you just need to point the FLAG function to a point in memory that you wish to store your data in, and you can manipulate as many flags as you need. each byte of memory can contain 8 flags. to setup the FLAG function, use the first syntax to point the function to a point in memory where the flags will be stored. once the pointer is setup, you can use the FLAG just like a variable using the second and third syntax for reading and writing the flags.
-------------------------

         FOR
syntax:  FOR numvar=number TO number STEP number
           ; NEXT

appears to have same function and limits as applesoft FOR-NEXT loops.
-------------------------

         FREE
syntax:  FREE

appears to have same function as applesoft FRE(0) command.
-------------------------

         GET
syntax:  GET varstr

the GET statement is used to get a single keypress from the keyboard. when encountered, the system will wait until a key is pressed. the key will be returned in <varstr>. control characters will not be filtered out as they are with INPUT.
-------------------------

         GOSUB
syntax:  GOSUB label

appears to have same function as applesoft GOSUB. only thing worth noting is that acos uses labels as targets instead of line numbers.
-------------------------

         GOTO
syntax:  GOTO label

appears to have same function as applesoft GOTO, again with the exception that acos uses labels not line numbers.
-------------------------

         HOME
syntax:  HOME

appears to have same function as applesoft HOME. clears current window.
-------------------------

         IF
syntax:  IF argument [THEN] statement [ELSE] statement

appears to have same function as applesoft IF-THEN except it supports the ELSE directive when the statement was false. ELSE is optional. THEN is also optional but if you use THEN, it cannot be followed by a label directly.(use IF arg THEN GOTO label).
-------------------------

         INFO
syntax:  expression=INFO(optional)
         INFO(optional)=expression

INFO can be used as either a statement or as a function. it is really a 'catch-all' in nature. many values that are more or less unrelated are returned. the following table gives the meanings of all the INFO data.

argument r/w       function
-------- ---       -----------------
INFO(0)  r         is there a caller online? (0=no)
INFO(1)  r         capacity of current message file.
INFO(2)  r         callers baud rate /300  (1=300)
INFO(3)  r/w       current number of nulls.
INFO(4)  w         top screen stats.  (1=chat, 2=exec)
INFO(5)  r/w       executive user online?  (1=yes)
INFO(6)  r         checks bit map for mail/msg bases for room.
-------------------------

         INPUT
syntax:  INPUT [#device,]  [@number,]  [\]  ["text"]
               variable [{,\}] variable..]

the INPUT statement is broken down into 4 different parts. the first part is the input device to be used. when omitted, the input is taken from the modem/console, otherwise input is taken from that device. the second part is the input mode. there is a restrictive mode placed on the input so that the inputed data is what you desire. the third part of INPUT is the prompt. the prompt is basically just a text string that will be printed prior to getting the input. the newline character '\' can be used at the beginning of the text. the last part of INPUT is the variable list. this is a list of variables that will be assigned the input. each variable in the list is separated by either a comma or backslash. if separated by a comma, then the actual typed input must be divided by a comma. if divided by a backslash, then the text must be separated by a carriage return.

         INPUT default- set the input mode to uppercase, don't accept a
                        blank line.

         INPUT mode 0 - set the input mode to uppercase, don't accept a
                        blank line, just return the first character.

         INPUT mode 1 - set the input mode to uppercase, don't accept a
                        blank line, don't accept any commas.

         INPUT mode 2 - set the input mode to uppercase, blank lines will
                        be accepted.

         INPUT mode 3 - accept everything. (upper & lower).
-------------------------

         INSTR
syntax:  expression=INSTR(string,string)

the INSTR function is used to search within a string for the existance of another string. the first string is that string which you are searching for. the second string is what will be searched. the case of the text will be ignored. the function will return the number of the first character where the match was found. if the function returns zero, no match was found.
-------------------------

         KEY
syntax:  expression=KEY(0)
         expression=KEY(1)
         expression=KEY(2)

the KEY function is used to check and see what if any keys have been pressed. it is generally used to check to see if a routine needs to be interrupted and is used in conjuction with the SETINT and ADDINT statements. this routine does not wait for a key, it returns either a zero for no key or the ascii value of the key. in the KEY(1) form, a non-zero byte will be returned if the key pressed was the 'file stop' character. in the KEY(2) form, a non-zero byte will be returned if the pressed key is the 'file next' key define in config.
-------------------------

         KILL
syntax:  KILL filename
         KILL #MSG(expression)

the KILL statement can be used in two different ways. in both ways it is used to delete data. in the first form, with the filename, it will delete the file from disk. in its second form, it will kill a message within the currently active message base. after using KILL on a message, it is always a good idea to follow it with an UPDATE.
-------------------------

         LEFT$
syntax:  string=LEFT$(string,length)

appears to have same function as applesoft LEFT$.
-------------------------

         LEN
syntax:  expression=LEN(string)

appears to have same function as applesoft LEN.
-------------------------

         LINK
syntax:  LINK filename [,string-label]

this statement will allow two program segments to be linked together. it is in this way that the problem of not enough memory is dealt with. the filename argument is mandatory and is in standard filename syntax. if you wish the execution to begin at a point other than the beginning of the module, then add on a comma followed by the name of the label IN STRING FORM. the label must be enclosed in quotes or must be in a string. ex: LINK "A:MSG.SEG","BULLETINS". you must also make use the PUBLIC command within the segment you are linking to so that the labels address is available to the link command.
-------------------------

         LOG
syntax:  LOG drivespec

the LOG statement simply changes the default disk drive to the <drivespec> drive. if the drive is not legal, a BAD DRIVE SPECIFIER error will occur.
-------------------------

         MARK
syntax:  expression=MARK(device)
         MARK(device)=number

the MARK function will allow you to either set or check the point at which a file is doing i/o. if you want to go to the beginning of a file, you would issue a MARK(1)=0 assuming it was file 1. MARK has a second function in that it can be used to see if a file exists. normally acos will not generate an error if a file exists, so it can be hard to tell if there is one. to see if a file exists:
                   OPEN #1,filename
                   IF MARK(1) PRINT "FILE EXISTS"
                   CLOSE #1
-------------------------

         MID$
syntax:  string=MID$(string,start [,length])

appears to have same function as applesoft MID$.
--------------------------

         MODEM
syntax:  MODEM(number)

the MODEM command is multiple function for controlling the modem.

                   MODEM(0)- this command needs to be issued before any other
                             modem command is used. its function is to
                             initialize the modem driver for later use.

                   MODEM(1)- this command waits for an incoming call and
                             establishes a connection. execution will continue
                             when either a call is connected or the user goes
                             into local mode.

                   MODEM(2)- this command causes the modem to hangup. all
                             further output will be sent to console only.
-------------------------

         MOVE
syntax:  MOVE start,length TO destination

the MOVE statement is used to move segments of memory around. the only limitation is that only a maximum of 255 bytes can be moved at any one time. both START and DESTINATION are 16 bit memory addresses while LENGTH is an 8 bit [0-255] number.
-------------------------

         MSG
syntax:  expression=MSG(number)
         MSG(number)=expression
         device={#MSG(number)}

the MSG function is a specialized function for the acos message handling routines. once a message file has been opened via the READY command, the MSG function is used to access individual messages within the message file. the MSG function has two radically different syntaxs. under the first and second syntax, it is being used to access and set information about a message. for each message, you can maintain one number that gives information about it via the MSG function. the MSG(0) function returns the number of messages within the message file and may not be changed. to access a message, it is used as a device channel. while to show the editor COPY#8 would suffice, since the message file is made up of many messages, it is necessary to tell which message you want to work with. COPY#MSG(3) would show message number three within the currently open message file.
-------------------------

         NEXT
syntax:  NEXT

similar to the applesoft NEXT statement which is used with FOR-NEXT loops but with the exception you cannot use a variable after NEXT. (NEXT X is illegal).
-------------------------

         NIBBLE
syntax:  NIBBLE=number
         NIBBLE(number)
         NIBBLE(number)=number16

the NEXT function is similar to the FLAG function in that it is a low overhead data storage method. with the NIBBLE function, you can store 4 bit numbers that have the range 0-15. use the first syntax of NIBBLE to point to the point in memory where the data will be stored. use the second and third syntax to read and write the actual data.
-------------------------

         NOT
syntax:  expression= NOT expression

the NOT operator is a booleon logic operator. it changes the value of an expression from true to false or from false to true. in booleon logic, false is considered to be zero while not false or true, is considered to be any other number. the NOT operator is most commonly used in IF statements.
-------------------------

         ON NOCAR
syntax:  ON NOCAR GOTO label

the ON NOCAR statement is used to setup a routine that can be used whne carrier is lost from a remote user. when the carrier is lost, acos will then hang up the modem. it will then change the current execution point to the label that was setup. whenever you link to another segment you must set up a new ON NOCAR vector to a routine within that segment. if you don't have a vector set up and a remote caller drops carrier, the system will just sit there until it times out.
-------------------------
       os will then hang up the modem. it will then change the current execution point to the label that was setup. whenever you link to another segment you must set up a new ON NOCAR vector to a routine within that segment. if you don't have a vector set up and a remote caller drops carrier, the system will just sit there until it times out.
-------------------------

      